{"version":3,"sources":["components/Content.js","lib/grafo/nodo.js","lib/grafo/arista.js","lib/conjunto-disjunto.js","lib/grafo/algoritmos.js","lib/grafo/grafo.js","components/RowLink.js","components/Row.js","components/Main.js","components/Header.js","components/NotDirected.js","components/MainNotDirected.js","components/InitialPage.js","assets/img/doc-ex.PNG","assets/img/link-ex.PNG","assets/img/graph.PNG","components/Documentation.js","App.js","index.js"],"names":["avoidNodeOverlap","node","pt","gridpt","isUnoccupied","r","navig","obj","part","go","isMemberOf","lit","diagram","layers","next","lay","value","isTemporary","findObjectsIn","count","bnds","actualBounds","loc","location","x","y","width","height","inflate","currentTool","_temp","layer","FDLayout","call","this","initDiagram","$","make","text","color","fig","initialAutoScale","Uniform","layout","model","linkKeyProperty","nodeTemplate","name","fill","strokeWidth","portId","margin","editable","font","makeTwoWay","dragComputation","linkTemplate","curve","Bezier","toArrow","segmentOffset","inherit","prototype","makeNetwork","coll","net","vertexes","each","vertex","isFixed","isSelected","Content","data","linksData","className","divClassName","nodeDataArray","linkDataArray","Adyacente","nodo","peso","Boolean","Direccion","Object","freeze","salida","entrada","ambas","Arista","origen","destino","from","to","link","Number","undefined","ConjuntoDisjunto","padre","grado","rx","buscar","ry","permutar","lista","length","cabeza","resto","permutacion","keys","i","slice","izquierda","derecha","f","caminoDeAumento","grafo","capacidad","Array","cantidad","cola","flujo","Infinity","isEmpty","shift","actual","adyacentes","siguiente","capacidadArista","flujoCamino","Math","min","push","Celda","conectada","desconectada","Trayecto","camino","ciclo","Grafo","esDirigido","listaDeAdyacencia","Map","n","matrizDeAdyacencia","map","j","celda","listaDeAristas","sortedUniq","flattenDeep","sort","a","b","nodos","visitar","first","includes","values","some","adyacente","direccion","existeArista","find","agregarArista","get","has","indiceMenor","sortedIndexBy","splice","ultimo","last","set","remove","explicitos","entrantes","unionBy","trayecto","matrizDeCaminos","identity","ultimaPotencia","add","multiply","toArray","distancia","noVisitados","Set","reduce","menor","distanciaDesdeOrigen","delete","reverse","candidatosOrigen","candidatosDestino","tipo","impares","impar","hierholzer","euleriano","cloneDeep","subtrayecto","pop","eliminarArista","esEuleriano","calculado","hamiltoniano","esTrayecto","anterior","arbol","conjunto","crear","aristas","arista","raizOrigen","raizDestino","unir","sumBy","entries","fila","listaDeLinks","desdeLink","RowLink","onChange","onRemove","FormControl","m","Box","display","justifyContent","p","TextField","id","label","type","InputProps","inputProps","max","InputLabelProps","shrink","e","target","Button","size","startIcon","style","fontSize","onClick","Row","fullWidth","Main","defaultState","useState","rows","setRows","links","setLinks","doneFetch","setDoneFetch","doneFetchDistance","setDoneFetchDistance","doneFetchHamEul","setDoneFetchHamEul","doneFetchFlujoMaximo","setDoneFetchFlujoMaximo","doneFetchArbol","setDoneFetchArbol","desde","hasta","changeData","setChangeData","changePeakData","setChangePeakData","edgesClass","setEdgesClass","setGrafo","arbolGenerador","setArbolGenerador","matrizDeCamino","setMatrizDeCamino","saveAllData","setSaveAllData","isHamiltoniano","setIsHamiltoniano","isEuleriano","setIsEuleriano","isConexo","setIsConexo","distance","setDistance","shortPath","setShortPath","distanceFrom","setDistanceFrom","distanceTo","setDistanceTo","peakFlowFrom","setPeakFlowFrom","peakFlowTo","setPeakFlowTo","peakFlow","setPeakFlow","validation","setValidation","eulerianPath","setEulerianPath","eulerianCycle","setEulerianCycle","hamiltonianPath","setHamiltonianPath","hamiltonianCycle","setHamiltonianCycle","grafoClass","numberFrom","numberTo","numberPeso","concat","handleArbol","handleFlujoMaximo","handleDistance","handleHamEul","handleMatriz","saveData","swal","gra","desdeListaDeAristas","esHamiltoniano","esConexo","agm","arbolGeneradorMinimo","caminoMasCorto","shortPathGraph","distanceShortes","peak","flujoMaximo","console","log","handleOnChangeLinks","index","copyLinks","edge","saveArista","handleInputChangeFromTo","preventDefault","peakFlowFromTo","getFromTo","handleInputPeakFlow","variant","len","row","copyRows","key","handleOnChange","handleOnRemove","handleOnRemoveLink","disabled","SaveAlt","item","miniItem","onSubmit","window","reload","Header","AppBar","position","Toolbar","NotDirected","MainNotDirected","InitialPage","Documentation","src","DocEx","alt","LinkEx","Graph","href","App","exact","path","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.fb97847d.chunk.js","sourcesContent":["import React from \"react\";\nimport * as go from \"gojs\";\nimport { ReactDiagram } from \"gojs-react\";\n\n// https://gojs.net/latest/samples/dragUnoccupied.html\nfunction avoidNodeOverlap(node, pt, gridpt) {\n  function isUnoccupied(r, node) {\n    let diagram = node.diagram;\n\n    function navig(obj) {\n      let part = obj.part;\n      if (part === node) return null;\n      if (part instanceof go.Link) return null;\n      if (part.isMemberOf(node)) return null;\n      if (node.isMemberOf(part)) return null;\n      return part;\n    }\n\n    let lit = diagram.layers;\n    while (lit.next()) {\n      let lay = lit.value;\n      if (lay.isTemporary) continue;\n      if (lay.findObjectsIn(r, navig, null, true).count > 0) return false;\n    }\n\n    return true;\n  }\n\n  if (node.diagram instanceof go.Palette) return gridpt;\n  let bnds = node.actualBounds;\n  let loc = node.location;\n  let r = new go.Rect(\n    gridpt.x - (loc.x - bnds.x),\n    gridpt.y - (loc.y - bnds.y),\n    bnds.width,\n    bnds.height\n  );\n\n  r.inflate(-0.5, -0.5);\n\n  if (\n    !(node.diagram.currentTool instanceof go.DraggingTool) &&\n    (!node._temp || !node.layer.isTemporary)\n  ) {\n    node._temp = true;\n    while (!isUnoccupied(r, node)) {\n      r.x += 10;\n      r.y += 2;\n    }\n    r.inflate(0.5, 0.5);\n    return new go.Point(r.x - (loc.x - bnds.x), r.y - (loc.y - bnds.y));\n  }\n  if (isUnoccupied(r, node)) return gridpt;\n  return loc;\n}\n\n// https://gojs.net/latest/samples/fdLayout.html\nfunction FDLayout() {\n  go.ForceDirectedLayout.call(this);\n}\n\ngo.Diagram.inherit(FDLayout, go.ForceDirectedLayout);\n\nFDLayout.prototype.makeNetwork = function (coll) {\n  let net = go.ForceDirectedLayout.prototype.makeNetwork.call(this, coll);\n\n  net.vertexes.each(function (vertex) {\n    let node = vertex.node;\n    if (node !== null) vertex.isFixed = node.isSelected;\n  });\n\n  return net;\n};\n\nfunction initDiagram() {\n  const $ = go.GraphObject.make;\n  const diagram = $(go.Diagram, {\n    \"undoManager.isEnabled\": true,\n    \"clickCreatingTool.archetypeNodeData\": { text: \"new node\", color: \"lightblue\", fig: \"Cloud\" },\n    initialAutoScale: go.Diagram.Uniform, // Zoom to make everything fit in the viewport.\n    layout: new FDLayout(),\n    model: $(go.GraphLinksModel, {\n      linkKeyProperty: \"key\",\n    }),\n  });\n\n  diagram.nodeTemplate = $(\n    go.Node,\n    \"Auto\", // the Shape will go around the TextBlock\n    new go.Binding(),\n    $(\n      go.Shape,\n      \"Circle\",\n      { name: \"SHAPE\", fill: \"white\", strokeWidth: 1, portId: \"\" },\n      // Shape.fill is bound to Node.data.color\n      new go.Binding(\"fill\", \"color\")\n    ),\n    $(\n      go.TextBlock,\n      { margin: 10, editable: false, font: \"26px Verdana\" },\n      new go.Binding(\"text\").makeTwoWay()\n    ),\n    { dragComputation: avoidNodeOverlap }\n  );\n\n  diagram.linkTemplate = $(\n    go.Link,\n    { curve: go.Link.Bezier },\n    $(go.Shape),\n    $(go.Shape, { toArrow: \"Standard\" }),\n    $(\n      go.TextBlock,\n      { font: \"24px Verdana\", segmentOffset: new go.Point(0, -20) },\n      new go.Binding(\"text\", \"text\")\n    )\n  );\n\n  return diagram;\n}\n\nconst Content = ({ data, linksData }) => {\n  return (\n    <div className=\"content\">\n      <ReactDiagram\n        initDiagram={initDiagram}\n        divClassName=\"diagram-component\"\n        nodeDataArray={data}\n        linkDataArray={linksData}\n      />\n    </div>\n  );\n};\n\nexport default Content;\n","/**\n * Representación de un nodo adyacente.\n * @class\n */\nclass Adyacente {\n  /*\n   * @constructor\n   * @param {number} nodo - Nodo adyacente.\n   * @param {number} peso - Peso de la arista.\n   */\n  constructor(nodo, peso) {\n    this.nodo = nodo;\n    this.peso = peso;\n  }\n\n  get esPonderado() {\n    return Boolean(this.peso);\n  }\n}\n\nexport { Adyacente };\n","import { Adyacente } from './nodo.js';\n\n/**\n * @enum {number}\n *\n * Representa la dirección de una arista.\n */\nconst Direccion = Object.freeze({\n  salida: 1,\n  entrada: 2,\n  ambas: 3,\n});\n\n/**\n * Representación de una arista.\n * @class\n */\nclass Arista {\n  /**\n   * @constructor\n   * @param {number} origen - Nodo origen.\n   * @param {number|Adyacente} destino - Nodo destino.\n   * @param {number} peso - Peso de la arista.\n   *\n   * Notar que si el nodo destino es de tipo `Adyacente`, el parámetro peso es\n   * ignorado.\n   */\n  constructor(origen, destino, peso) {\n    this.origen = origen;\n\n    if (destino instanceof Adyacente) {\n      this.destino = destino.nodo;\n      this.peso = destino.peso;\n    } else {\n      this.destino = destino;\n      this.peso = peso;\n    }\n  }\n\n  /**\n   * @typedef {Object} Link\n   *   @property {string} from - Origen de la arista.\n   *   @property {string} to - Destino de la arista.\n   *   @property {string} text - Peso de la arista.\n   */\n  /**\n   * Construye una lista a partir de un link.\n   *\n   * @param {Link} link - Link.\n   */\n  static desdeLink(link) {\n    const { from, to, text } = link;\n    return new Arista(Number(from), Number(to), text == null ? undefined : Number(text));\n  }\n\n  /**\n   * Comprueba si la arista es ponderada.\n   *\n   * @returns {boolean} `true` si la arista es ponderada, `false` en caso\n   * contrario.\n   */\n  get esPonderada() {\n    return this.peso != null;\n  }\n\n  /**\n   * Convierte la arista a un link.\n   *\n   * @returns {Link} Link.\n   */\n  get link() {\n    return {\n      from: this.origen,\n      to: this.destino,\n      text: this.peso,\n    };\n  }\n}\n\nexport { Arista, Direccion };\n","/**\n * Representación de un conjunto disjunto.\n * @class\n */\nclass ConjuntoDisjunto {\n  /**\n   * @constructor\n   */\n  constructor() {\n    this.padre = [];\n    this.grado = [];\n  }\n\n  /**\n   * Crea un nuevo conjunto, donde el nodo x es el único nodo del conjunto.\n   *\n   * @param {any} x - Nodo a agregar.\n   * @returns {void}\n   */\n  crear(x) {\n    this.padre[x] = x;\n    this.grado[x] = 0;\n  }\n\n  /**\n   * Busca el nodo raíz que representa al conjunto que contiene al nodo x.\n   *\n   * @param {any} x - Nodo cuya raíz representativa es buscada.\n   * @returns {any} Raíz que representa al conjunto que contiene al nodo x.\n   *\n   * Implementación del algoritmo de división de camino, de una pasada.\n   */\n  buscar(x) {\n    while (x !== this.padre[x]) {\n      // Reemplaza cada nodo por su padre, y cada padre por su respectivo padre.\n      [x, this.padre[x]] = [this.padre[x], this.padre[this.padre[x]]];\n    }\n\n    return x;\n  }\n\n  /**\n   * Une los conjuntos de los elementos x e y en un sólo conjunto.\n   *\n   * @param {any} x - Nodo cuyo conjunto se une con el conjunto del nodo y.\n   * @param {any} y - Nodo cuyo conjunto se une con el conjunto del nodo x.\n   * @returns {boolean} `true` si los conjuntos fueron unidos, `false` en caso contrario.\n   *\n   * Implementación del algoritmo de unión por grado (rank).\n   */\n  unir(x, y) {\n    // Raíz del nodo x.\n    let rx = this.buscar(x);\n\n    // Raíz del nodo y.\n    let ry = this.buscar(y);\n\n    if (rx === ry) {\n      // Los elementos ya están en el mismo conjunto.\n      return false;\n    }\n\n    // Si es necesario, reasignar las variables para garantizar que el grado de x es\n    // mayor o igual que el grado de y.\n    if (this.grado[rx] < this.grado[ry]) {\n      [rx, ry] = [ry, rx];\n    }\n\n    // Establecer a la raíz de x como la nueva raíz de y.\n    this.padre[ry] = rx;\n\n    // Si el grado de la raíz de x es igual al grado de la raíz de y, aumenta el grado de x\n    // (aumenta el límite superior de la altura del nodo x).\n    if (this.grado[rx] === this.grado[ry]) {\n      this.grado[rx] += 1;\n    }\n\n    // Los conjuntos del nodo x e y fueron unidos.\n    return true;\n  }\n}\n\nexport { ConjuntoDisjunto };\n","import { isEmpty } from \"lodash-es\";\nimport { Direccion } from \"./arista.js\";\n\n/**\n * Produce una permutación de una lista de números.\n *\n * @param {number[]} lista - Lista a calcular permutaciones.\n * @yields {number[]} La siguiente permutación de la lista de números.\n */\nexport function* permutar(lista) {\n  // Caso base.\n  if (lista.length === 1) {\n    yield lista;\n  } else {\n    // Obtiene el primer elemento de la lista, y el resto de la lista.\n    let [cabeza, ...resto] = lista;\n\n    // Generación recursiva de permutaciones, una por cada iteración.\n    for (const permutacion of permutar(resto)) {\n      for (const i of lista.keys()) {\n        // Divide en 2 la permutación, en el índice j.\n        const [izquierda, derecha] = [permutacion.slice(0, i), permutacion.slice(i)];\n\n        // Produce la siguiente permutación.\n        yield [...izquierda, cabeza, ...derecha];\n      }\n    }\n  }\n}\n\n/**\n * @typedef {Object} CaminoDeAumento\n *   @property {number} flujoCamino - Capacidad residual mínima del camino\n *   de aumento.\n *   @property {number[]} padre - Lista de padres de cada nodo, siguiendo el\n *   camino de aumento.\n */\n/**\n * Recorre el grafo para encontrar un camino de aumento (CA).\n *\n * @param {number} entrada - Nodo donde comienza el camino de aumento.\n * @param {number} salida - Nodo donde termina el camino de aumento.\n * @param {number[][]} capacidad - Matriz de capacidades residuales de las\n * aristas del grafo.\n * @returns {CaminoDeAumento} Flujo del camino de aumento, y lista de padres\n * de cada nodo, siguiendo el mismo camino de aumento.\n *\n * Algoritmo de búsqueda en anchura (breadth-first search, BFS).\n */\nexport function caminoDeAumento(grafo, entrada, salida, capacidad) {\n  // Arreglo utilizado para recordar los nodos padres de cada nodo i-ésimo\n  // (si es que fue visitado).\n  let padre = Array(grafo.cantidad);\n\n  // El nodo entrada no tiene padre.\n  padre[entrada] = null;\n\n  // Se utiliza una cola para almacenar los nodos que están en el mismo\n  // nivel del nodo actual (nodo entrada, inicialmente), más el flujo del\n  // CA asociado al nodo ingresado.\n  for (let cola = [{ nodo: entrada, flujo: Infinity }]; !isEmpty(cola); ) {\n    // Extrae el primer elemento de la cola.\n    const { nodo: actual, flujo } = cola.shift();\n\n    // Se exploran los adyacentes (de salida y de entrada) del nodo actual.\n    for (const { nodo: siguiente } of grafo.adyacentes(actual, Direccion.ambas)) {\n      // Capacidad residual de la arista {actual, siguiente}.\n      const capacidadArista = capacidad[actual][siguiente];\n\n      // Comprueba si el nodo siguiente no ha sido visitado (porque su padre\n      // no está definido) y si la capacidad residual de la arista {actual,\n      // siguiente} es positiva.\n      if (padre[siguiente] === undefined && capacidadArista > 0) {\n        // Recordar el nodo padre (nodo actual) del nodo siguiente.\n        padre[siguiente] = actual;\n\n        // Calcula la capacidad residual menor del CA.\n        let flujoCamino = Math.min(flujo, capacidadArista);\n\n        // Comprueba si se ha llegado al final del CA.\n        if (siguiente === salida) {\n          return { flujoCamino, padre };\n        }\n\n        // Ingresa a la cola el nodo siguiente (un nivel más abajo del nodo\n        // de entrada).\n        cola.push({ nodo: siguiente, flujo: flujoCamino });\n      }\n    }\n  }\n\n  // Si el flujo del camino es 0, entonces no se encontró ningún CA.\n  return { flujoCamino: 0, padre };\n}\n","import { Arista, Direccion } from \"./arista.js\";\nimport { Adyacente } from \"./nodo.js\";\nimport { ConjuntoDisjunto } from \"../conjunto-disjunto.js\";\nimport { permutar, caminoDeAumento } from \"./algoritmos.js\";\nimport { identity, add, multiply } from \"mathjs/lib/esm/index.js\";\nimport {\n  cloneDeep,\n  find,\n  first,\n  flattenDeep,\n  isEmpty,\n  last,\n  remove,\n  some,\n  sumBy,\n  unionBy,\n  sortedIndexBy,\n  sortedUniq,\n} from \"lodash-es\";\n\n/**\n * @enum {boolean}\n *\n * Representa la conexión entre dos nodos i y j en la celda {i, j} de la matriz\n * de adyacencia.\n */\nconst Celda = Object.freeze({\n  conectada: true,\n  desconectada: false,\n});\n\n/**\n * @enum {number}\n *\n * Representa los tipos de trayecto en un grafo.\n */\nconst Trayecto = Object.freeze({\n  camino: 1,\n  ciclo: 2,\n});\n\n/**\n * Representación de un grafo.\n * @class\n */\nclass Grafo {\n  /**\n   * @constructor\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\n   * adyacencia es dirigido, `false` en caso contrario.\n   */\n  constructor(esDirigido = false) {\n    this.listaDeAdyacencia = new Map();\n    this.esDirigido = esDirigido;\n  }\n\n  /**\n   * Construye un grafo a partir de una lista de adyacencia.\n   *\n   * @param {Map<number, number[]>} listaDeAdyacencia - Lista de adyacencia.\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\n   * adyacencia es dirigido, `false` en caso contrario.\n   * @returns {Grafo} Grafo.\n   *\n   * La implementación interna de `Grafo` es una lista de adyacencia, por lo que\n   * éste constructor redirige al constructor principal.\n   *\n   * @example\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\n   * const listaDeAdyacencia = [\n   *   [0, [new Adyacente(1, 2), new Adyacente(2, 6)]],\n   *   [1, [new Adyacente(2, 3)]],\n   *   [2, [new Adyacente(0, 4)]]\n   * ];\n   *\n   * // La lista de adyacencia contiene aristas dirigidas.\n   * const esDirigido = true;\n   * const grafo = Grafo.desdeListaDeAdyacencia(matrizDeAdyacencia, esDirigido);\n   */\n  static desdeListaDeAdyacencia(listaDeAdyacencia, esDirigido = false) {\n    let grafo = new Grafo(esDirigido);\n\n    for (const [i, adyacentes] of listaDeAdyacencia) {\n      for (const { nodo: j, peso } of adyacentes) {\n        grafo.agregarArista(i, j, peso, Direccion.salida);\n      }\n    }\n\n    return grafo;\n  }\n\n  /**\n   * Construye un grafo a partir de una matriz de adyacencia.\n   *\n   * @param {number[][]} matrizDeAdyacencia - Matriz de adyacencia.\n   * @param {boolean} esDirigido - `true` si el grafo de la matriz de adyacencia\n   * es dirigido, `false` en caso contrario.\n   * @returns {Grafo} Grafo.\n   *\n   * @example\n   * // Grafo: 0 -> 1, 0 <-> 2, 1 -> 2.\n   * const matrizDeAdyacencia = [\n   *   [false, true, true],\n   *   [false, false, true],\n   *   [true, false, false]\n   * ];\n   *\n   * // La matriz contiene aristas dirigidas.\n   * const esDirigido = true;\n   * const grafo = Grafo.desdeMatrizDeAdyacencia(\n   *   matrizDeAdyacencia, esDirigido\n   * );\n   */\n  static desdeMatrizDeAdyacencia(matrizDeAdyacencia, esDirigido = false) {\n    let grafo = new Grafo(esDirigido);\n\n    for (const [i, fila] of matrizDeAdyacencia.entries()) {\n      for (const [j, celda] of fila.entries()) {\n        if (celda !== Celda.desconectada) {\n          grafo.agregarArista(\n            i,\n            j,\n            celda === Celda.conectada ? undefined : celda,\n            Direccion.salida\n          );\n        }\n      }\n    }\n\n    return grafo;\n  }\n\n  /**\n   * Construye un grafo a partir de una lista de aristas.\n   *\n   * @param {number[][]} listaDeAristas - Lista de aristas.\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\n   * adyacencia es dirigido, `false` en caso contrario.\n   * @returns {Grafo} Grafo.\n   *\n   * @example\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\n   * const listaDeAristas = [\n   *   new Arista(0, 1, 2),\n   *   new Arista(0, 2, 6),\n   *   new Arista(1, 2, 3),\n   *   new Arista(2, 0, 4)\n   * ];\n   *\n   * // La lista contiene aristas dirigidas.\n   * const esDirigido = true;\n   * const grafo = Grafo.desdeListaDeAristas(listaDeAristas, esDirigido);\n   */\n  static desdeListaDeAristas(listaDeAristas, esDirigido = false) {\n    let grafo = new Grafo(esDirigido);\n\n    for (const { origen, destino, peso } of listaDeAristas) {\n      grafo.agregarArista(origen, destino, peso, Direccion.salida);\n    }\n\n    return grafo;\n  }\n\n  /**\n   * @typedef {Object} Link\n   *   @property {string} from - Origen de la arista.\n   *   @property {string} to - Destino de la arista.\n   *   @property {string} text - Peso de la arista.\n   */\n  /**\n   * Construye un grafo a partir de una lista de links.\n   *\n   * @param {Link[]} listaDeLinks - Lista de links.\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la lista de\n   * links es dirigido, `false` en caso contrario.\n   *\n   * @example\n   * // Grafo: 0 --(1)--> 1, 0 --(4)--> 2, 0 --(7)--> 3, 1 --(9)--> 2.\n   * const listaDeLinks = [\n   *   { from: \"0\", to: \"1\", text: \"1\" },\n   *   { from: \"0\", to: \"2\", text: \"4\" },\n   *   { from: \"0\", to: \"3\", text: \"7\" },\n   *   { from: \"1\", to: \"2\", text: \"9\" },\n   * ];\n   *\n   * // La lista de links no contiene aristas dirigidas.\n   * const esDirigido = false;\n   * const grafo = Grafo.desdeListaDeLinks(listaDeLinks, esDirigido);\n   */\n  static desdeListaDeLinks(listaDeLinks, esDirigido = false) {\n    let grafo = new Grafo(esDirigido);\n\n    for (const link of listaDeLinks) {\n      const { origen, destino, peso } = Arista.desdeLink(link);\n      grafo.agregarArista(origen, destino, peso, Direccion.salida);\n    }\n\n    return grafo;\n  }\n\n  /**\n   * Obtiene la matriz de adyacencia asociada al grafo.\n   *\n   * @returns {number[][]} Matriz de adyacencia.\n   */\n  get matrizDeAdyacencia() {\n    const n = this.cantidad;\n\n    // Crea una matriz de orden n, cuyos valores son inicialmente `false`.\n    let matrizDeAdyacencia = Array(n)\n      .fill()\n      .map(() => Array(n).fill(Celda.desconectada));\n\n    for (const [i, adyacentes] of this.listaDeAdyacencia) {\n      for (const { nodo: j, peso: celda } of adyacentes) {\n        // Si el adyacente es ponderado, el valor de la celda {i, j} corresponde\n        // al peso de la arista que une al nodo i con el nodo j. En caso\n        // contrario, a la celda {i, j} se la asigna `true`.\n        matrizDeAdyacencia[i][j] = celda ?? Celda.conectada;\n\n        // La matriz de adyacencia de un grafo no dirigido es simétrica, por\n        // lo que la arista entre el nodo i y el nodo j existe en dicha matriz\n        // tanto en {i, j} y como en {j, i}.\n        if (!this.esDirigido) {\n          matrizDeAdyacencia[j][i] = celda ?? Celda.conectada;\n        }\n      }\n    }\n\n    return matrizDeAdyacencia;\n  }\n\n  /**\n   * Obtiene la lista de aristas asociada al grafo.\n   *\n   * @returns {number[][]} Lista de aristas.\n   */\n  get listaDeAristas() {\n    let listaDeAristas = [];\n\n    for (const [origen, adyacentes] of this.listaDeAdyacencia) {\n      for (const { nodo: destino, peso } of adyacentes) {\n        listaDeAristas.push(new Arista(origen, destino, peso));\n      }\n    }\n\n    return listaDeAristas;\n  }\n\n  /**\n   * Obtiene la lista con todos los nodos del grafo.\n   *\n   * @returns {number[]} Lista de nodos.\n   */\n  get nodos() {\n    // Descomprime el arreglo interno de la lista de adyacencia en un arreglo de\n    // una dimensión, se omite el peso de los adyacentes ponderados, se ordenan\n    // los nodos ascendentemente y se filtran los duplicados.\n    return sortedUniq(\n      flattenDeep([...this.listaDeAdyacencia])\n        .map((nodo) => nodo?.nodo ?? nodo)\n        .sort((a, b) => a - b)\n    );\n  }\n\n  /**\n   * Calcula la cantidad de nodos del grafo.\n   *\n   * @returns {number} Cantidad de nodos.\n   */\n  get cantidad() {\n    return this.nodos.length;\n  }\n\n  /**\n   * Comprueba si el grafo es conexo.\n   *\n   * @returns {boolean} `true` si el grafo es conexo, `false` en caso contrario.\n   */\n  get esConexo() {\n    /**\n     * Recorre el grafo.\n     *\n     * @param {number} origen - Nodo donde comienza el recorrido.\n     * @returns {number[]} Nodos padre de cada nodo i-ésimo (si fue visitado).\n     *\n     * Algoritmo de búsqueda en anchura (breadth-first search, BFS).\n     */\n    const visitar = (origen) => {\n      // Arreglo utilizado para recordar los nodos padres de cada nodo i-ésimo\n      // (si es que fue visitado).\n      let padre = Array(this.cantidad);\n\n      // El nodo origen no tiene padre.\n      padre[origen] = null;\n\n      // Se utiliza una cola para almacenar los nodos que están en el mismo\n      // nivel del nodo actual (nodo origen, inicialmente).\n      for (let cola = [origen]; !isEmpty(cola); ) {\n        // Extrae el primer elemento de la cola.\n        const actual = cola.shift();\n\n        // Se exploran los adyacentes del nodo actual.\n        for (const { nodo: siguiente } of this.adyacentes(actual)) {\n          // Comprueba si el nodo siguiente no ha sido visitado (porque su padre\n          // no está definido).\n          if (padre[siguiente] === undefined) {\n            // Recordar el nodo padre (nodo actual) del nodo siguiente.\n            padre[siguiente] = actual;\n\n            // Ingresa a la cola el nodo siguiente (un nivel más abajo del nodo\n            // origen).\n            cola.push(siguiente);\n          }\n        }\n      }\n\n      return padre;\n    };\n\n    // Si al recorrer el grafo, uno de los nodos no fue visitado, entonces el\n    // grafo no es conexo.\n    return !visitar(first(this.nodos)).includes(undefined);\n  }\n\n  /**\n   * Comprueba si el grafo es ponderado.\n   *\n   * @returns {boolean} `true` si el grafo es ponderado, `false` en caso\n   * contrario.\n   */\n  get esPonderado() {\n    // Comprueba si alguno de los adyacentes de la lista de adyacencia es\n    // ponderado.\n    return [...this.listaDeAdyacencia.values()].some((adyacente) => some(adyacente, \"esPonderado\"));\n  }\n\n  /**\n   * Comprueba si existe una arista entre el nodo origen y el nodo destino.\n   *\n   * @param {number} origen - Nodo origen.\n   * @param {number} destino - Nodo destino.\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\n   * buscada.\n   * @returns {boolean} `true` si la arista entre el nodo origen y el nodo\n   * destino existe, `false` en caso contrario.\n   *\n   * @todo Aristas no dirigidas vs doble aristas de salida y de entrada\n   * (multigrafo). Ver también método `arista`.\n   */\n  existeArista(origen, destino, direccion = Direccion.salida) {\n    return some(this.adyacentes(origen, direccion), [\"nodo\", destino]);\n  }\n\n  /**\n   * Comprueba si existe una arista entre el nodo origen y el nodo destino.\n   *\n   * @param {number} origen - Nodo origen.\n   * @param {number} destino - Nodo destino.\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\n   * buscada.\n   * @returns {Arista|boolean} Arista, si existe; `false`, en caso contrario.\n   *\n   * @todo Aristas no dirigidas vs doble aristas de salida y de entrada\n   * (multigrafo). Ver también método `existeArista`.\n   */\n  arista(origen, destino, direccion = Direccion.salida) {\n    if (!this.existeArista(origen, destino, direccion)) {\n      return false;\n    }\n\n    // Encuentra el nodo destino en los adyacentes de entrada (si la arista\n    // encontrada es sólo de entrada) o en los adyacentes de salida (si la\n    // arista encontrada es sólo de salida, o de salida y además de entrada).\n    const { peso } = find(this.adyacentes(origen, direccion), [\"nodo\", destino]);\n\n    // Si se desea obtener una arista de entrada (es decir, dirigida desde el\n    // destino hacia el origen), se debe intercambiar el destino con el origen.\n    if (direccion === Direccion.entrada) {\n      return new Arista(destino, origen, peso);\n    }\n\n    return new Arista(origen, destino, peso);\n  }\n\n  /**\n   * Crea una arista entre dos nodos de un grafo.\n   *\n   * @param {number} origen - Nodo origen.\n   * @param {number} destino - Nodo destino.\n   * @param {number} peso - Peso de la arista que une los nodos.\n   * @param {Direccion} direccion - Dirección de la arista entre los nodos.\n   * @returns {boolean} `true` si los nodos fueron conectados, `false` en caso\n   * contrario (los nodos ya estaban conectados).\n   */\n  agregarArista(origen, destino, peso, direccion = Direccion.salida) {\n    // Si la arista ya existe, no hay nada que insertar.\n    if (this.existeArista(origen, destino, direccion)) {\n      return false;\n    }\n\n    // Si el grafo es dirigido y la arista es de entrada, invertir los extremos.\n    else if (this.esDirigido && direccion === Direccion.entrada) {\n      return this.agregarArista(destino, origen, peso, Direccion.salida);\n    }\n\n    // Garantizar que el nodo origen es siempre menor al nodo destino.\n    else if (!this.esDirigido && origen > destino) {\n      [origen, destino] = [destino, origen];\n    }\n\n    let adyacentes = this.listaDeAdyacencia.get(origen);\n    const adyacente = new Adyacente(destino, peso);\n\n    if (this.listaDeAdyacencia.has(origen)) {\n      // Determina el índice mínimo en el que el adyacente debe ser insertado\n      // para mantener la lista de adyacentes ordenada.\n      const indiceMenor = sortedIndexBy(adyacentes, adyacente, \"nodo\");\n      adyacentes.splice(indiceMenor, 0, adyacente);\n    } else {\n      const ultimo = last([...this.listaDeAdyacencia.keys()]);\n      this.listaDeAdyacencia.set(origen, [adyacente]);\n\n      // Si existe un nodo mayor al nodo origen, ordenar la lista de adyacencia.\n      if (origen < ultimo) {\n        this.listaDeAdyacencia = new Map(\n          [...this.listaDeAdyacencia].sort((a, b) => first(a) - first(b))\n        );\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Elimina la arista, si existe, entre el nodo origen y el nodo destino.\n   *\n   * @param {number} origen - Nodo origen.\n   * @param {number} destino - Nodo destino.\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\n   * buscada.\n   * @returns {Adyacente[]|boolean} Si la arista existía, adyacentes explícitos\n   * del nodo origen; `false`, en caso contrario.\n   */\n  eliminarArista(origen, destino, direccion = Direccion.salida) {\n    if (!this.existeArista(origen, destino, direccion)) {\n      return false;\n    }\n\n    // Si la arista es dirigida hacia el origen, invertir los vértices.\n    // Para los grafos no dirigidos, basta con eliminar la arista de salida.\n    else if (this.esDirigido && direccion === Direccion.entrada) {\n      return remove(this.listaDeAdyacencia.get(destino), [\"nodo\", origen]);\n    }\n\n    // Si el grafo no es dirigido, asegurarse que el origen sea siempre menor\n    // que el destino.\n    else if (!this.esDirigido && origen > destino) {\n      [origen, destino] = [destino, origen];\n    }\n\n    return remove(this.listaDeAdyacencia.get(origen), [\"nodo\", destino]);\n  }\n\n  /**\n   * Obtiene los nodos adyacentes (de salida o entrada) a un nodo.\n   *\n   * @param {number} nodo - Nodo.\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de los nodos\n   * adyacentes al nodo.\n   * @returns {!Adyacente[]} Adyacentes al nodo.\n   *\n   * @example\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\n   * const listaDeAdyacencia = [\n   *   [0, [new Adyacente(1, 2), new Adyacente(2, 6)]],\n   *   [1, [new Adyacente(2, 3)]],\n   *   [2, [new Adyacente(0, 4)]]\n   * ];\n   *\n   * // La lista de adyacencia contiene aristas dirigidas.\n   * const esDirigido = true;\n   * const grafo = new Grafo(listaDeAdyacencia, esDirigido);\n   *\n   * console.log(grafo.adyacentes(0, Direccion.entrada));\n   * // Valor esperado:\n   * // [new Adyacente(2, 4)]\n   */\n  adyacentes(nodo, direccion = Direccion.salida) {\n    /**\n     * Obtiene los nodos adyacentes que interna y explícitamente están\n     * asociados al nodo origen.\n     *\n     * @param {number} nodo - Nodo origen.\n     * @returns {!Adyacente[]} Lista de adyacentes de salida.\n     *\n     * Debido al funcionamiento de las listas de adyacencia, un nodo de un\n     * grafo no dirigido tiene nodos adyacentes que no están explícitamente\n     * asociados en dicha lista de adyacencia.\n     */\n    const explicitos = (nodo) => {\n      return this.listaDeAdyacencia.get(nodo) ?? [];\n    };\n\n    /**\n     * Obtiene los nodos adyacentes de salida del nodo.\n     *\n     * @param {number} nodo - Nodo origen.\n     * @returns {!Adyacente[]} Lista de adyacentes de salida.\n     *\n     * Los nodos adyacentes de entrada son aquellos que entregan alguna\n     * conexión al nodo origen.\n     */\n    const entrantes = (nodo) => {\n      let entrantes = [];\n\n      for (const [origen, adyacentes] of this.listaDeAdyacencia) {\n        let destino = find(adyacentes, [\"nodo\", nodo]);\n        if (destino != null) {\n          entrantes.push(new Adyacente(origen, destino.peso));\n        }\n      }\n\n      return entrantes;\n    };\n\n    // En los grafos no dirigidos las aristas no tienen dirección, pero como\n    // algunos adyacentes no están explícitos en la lista de adyacencia,\n    // se deben agregar los adyacentes implícitos (o de entrada, en caso de un\n    // grafo dirigido).\n    if (!this.esDirigido || direccion === Direccion.ambas) {\n      return unionBy(explicitos(nodo), entrantes(nodo), \"nodo\");\n    } else if (direccion === Direccion.salida) {\n      return explicitos(nodo);\n    } else if (direccion === Direccion.entrada) {\n      return entrantes(nodo);\n    }\n\n    // El nodo no tiene adyacentes.\n    return [];\n  }\n\n  /**\n   * Calcula el grado de un nodo.\n   *\n   * @param {number} nodo - Nodo.\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de los nodos\n   * adyacentes considerados en el grado.\n   * @returns {number} Grado del nodo.\n   *\n   * @todo Considerar caso de aristas bucle.\n   */\n  grado(nodo, direccion = Direccion.salida) {\n    // Si el grafo es dirigido, y se espera el grado total de un nodo, retornar\n    // la suma del grado de salida más el grado de entrada del nodo. En los\n    // grafos no dirigidos no hay distinción de dirección.\n    if (this.esDirigido && direccion === Direccion.ambas) {\n      return this.grado(nodo, Direccion.salida) + this.grado(nodo, Direccion.entrada);\n    }\n\n    // Se obtienen los adyacentes con la dirección específicada y se retorna la\n    // cantidad de ellos. Si el grafo no es dirigido, y no se provee una\n    // dirección específica, se retorna el grado de salida como grado total (no\n    // hay distinción de dirección en los grafos no dirigidos).\n    return this.adyacentes(nodo, direccion).length;\n  }\n\n  /**\n   * Comprueba si un trayecto es válido en el grafo.\n   *\n   * @param {number[]} trayecto - Trayecto.\n   * @returns {boolean} `true` si el  trayecto es válido en el grafo, `false` en\n   * caso contrario.\n   */\n  esTrayecto(trayecto) {\n    for (let i = 0; i < trayecto.length - 1; i++) {\n      // Comprueba que exista una arista (de salida) entre cada par de nodos\n      // {i, i + 1}.\n      if (!this.existeArista(trayecto[i], trayecto[i + 1])) {\n        // El trayecto no es válido dentro del grafo.\n        return false;\n      }\n    }\n\n    // El trayecto es válido dentro del grafo.\n    return true;\n  }\n\n  /**\n   * Obtiene la matriz de caminos asociada al grafo.\n   *\n   * @returns {number[][]} Matriz de caminos.\n   *\n   * El cálculo de la matriz de caminos está definido como la sumatoria de\n   * `A^i`, desde `i = 0`, hasta `i = n - 1`, donde `A` es la matriz de\n   * adyacencia del grafo, y n es la cantidad de nodos del mismo grafo. Desde `i\n   * = 2`, el resultado de `A^(i - 1)` se recuerda, para calcular el próximo\n   * término `A^i` como `A^(i - 1) * A`.\n   */\n  get matrizDeCaminos() {\n    const matrizDeAdyacencia = this.matrizDeAdyacencia;\n    const n = this.cantidad;\n\n    // A^0 es la matriz de identidad de orden n.\n    let matrizDeCaminos = identity(n);\n\n    // Como la iteración comienza en i = 2, se recuerda el valor de A^(i - 1),\n    // es decir, la matriz de adyacencia.\n    let ultimaPotencia = matrizDeAdyacencia;\n\n    for (let i = 2; i <= n; i++) {\n      matrizDeCaminos = add(matrizDeCaminos, ultimaPotencia);\n\n      // Calcular A^i como A^(i - 1) * A.\n      ultimaPotencia = multiply(ultimaPotencia, matrizDeAdyacencia);\n    }\n\n    return matrizDeCaminos.toArray();\n  }\n\n  /**\n   * @typedef {Object} CaminoMasCorto\n   *   @property {boolean|number[]} camino - Camino más corto entre el nodo\n   *   origen y el nodo destino, si existe; `false`, en caso contrario.\n   *   @property {number} distancia - Distancia total del camino más corto.\n   */\n  /** Obtiene el camino más corto entre dos nodos.\n   *\n   * @param {number} origen - Nodo origen.\n   * @param {number} destino - Nodo destino.\n   * @returns {CaminoMasCorto} Camino más corto y distancia total.\n   *\n   * Implementación del algoritmo de caminos mínimos de Dijkstra.\n   *\n   * @namespace caminoMasCorto\n   */\n  caminoMasCorto(origen, destino) {\n    const n = this.cantidad;\n\n    // Se recuerdan los nodos padres de cada nodo i-ésimo visitado, siguiendo la\n    // ruta óptima.\n    let padre = Array(n);\n\n    // Distancias (inicialmente infinitas) desde el nodo origen a cada nodo\n    // i-ésimo del grafo.\n    let distancia = Array(n).fill(Infinity);\n\n    // La distancia del nodo origen a sí mismo es 0.\n    distancia[origen] = 0;\n\n    for (let noVisitados = new Set(this.nodos); !isEmpty(noVisitados); ) {\n      // Se obtiene el nodo no visitado más cercano al nodo origen.\n      const actual = [...noVisitados].reduce((menor, nodo) =>\n        distancia[nodo] < distancia[menor] ? nodo : menor\n      );\n\n      // Si el nodo actual es el nodo destino, no es necesario seguir explorando\n      // sus adyacentes.\n      if (actual === destino) {\n        break;\n      }\n\n      // Se itera sobre todos los nodos adyacentes al nodo actual. Si el nodo no\n      // es ponderado, asignarle peso 1.\n      for (const { nodo: siguiente, peso } of this.adyacentes(actual)) {\n        // Calcula la distancia total desde el nodo origen hasta el actual.\n        const distanciaDesdeOrigen = distancia[actual] + (peso ?? 1);\n\n        // Si ésta distancia es menor a la registrada actualmente, se actualizan\n        // las distancias y los padres.\n        if (distanciaDesdeOrigen < distancia[siguiente]) {\n          distancia[siguiente] = distanciaDesdeOrigen;\n          padre[siguiente] = actual;\n        }\n      }\n\n      noVisitados.delete(actual);\n    }\n\n    // Si la distancia del nodo origen al nodo destino es infinita, entonces\n    // no existe un camino que los una.\n    if (distancia[destino] === Infinity) {\n      return { camino: false, distancia: 0 };\n    }\n\n    // Se calcula el camino más corto a partir de los nodos padres.\n    let camino = new Set([destino]);\n\n    // Se itera inversamente los nodos padres (del nodo destino al nodo origen).\n    for (let nodo = padre[destino]; nodo != null; nodo = padre[nodo]) {\n      camino.add(nodo);\n    }\n\n    // HACK: hay casos en que el origen ya viene incluido en el camino.\n    // Retorna el camino más corto (incluyendo el nodo origen) y la distancia\n    // total de la ruta.\n    return {\n      camino: [...camino.add(origen)].reverse(),\n      distancia: distancia[destino],\n    };\n  }\n\n  /**\n   * @typedef {Object} InfoTrayecto\n   *   @property {Trayecto} tipo - Tipo de trayecto (camino, ciclo, o ninguno).\n   *   @property {?number} origen - Nodo que origina el trayecto.\n   */\n  /**\n   * Determina si el grafo contiene un trayecto euleriano.\n   *\n   * @returns {InfoTrayecto|boolean} Tipo de trayecto (camino o ciclo) y nodo\n   * que origina el trayecto, si existe; `false`, en caso contrario.\n   *\n   * Condiciones que el grafo debe cumplir para que contenga un trayecto\n   * euleriano, donde GE es el grado de entrada de un nodo, y GS el grado de\n   * salida:\n   *            ┌─────────────────────────┬───────────────────────────────────┐\n   *            │     Ciclo euleriano     │          Camino euleriano         │\n   * ┌──────────┼─────────────────────────┼───────────────────────────────────┤\n   * │ No       │ Todos los nodos tienen  │ Todos los nodos tienen grado par, │\n   * │ dirigido │ grado par.              │ o exactamente 2 nodos tienen      │\n   * │          │                         │ grado impar. (1)                  │\n   * ├──────────┼─────────────────────────┼───────────────────────────────────┤\n   * │ Dirigido │ Todos los nodos cumplen │ A lo más 1 nodo cumple que:       │\n   * │          │ que GE = GS.            │ GS - GE = 1,                      │\n   * │          │                         │ Y, a lo más 1 nodo cumple que:    │\n   * │          │                         │ GE - GS = 1 (o GS - GE = -1)      │\n   * │          │                         │ Y, el resto de nodos cumplen que: │\n   * │          │                         │ GE = GS.                          │\n   * └──────────┴─────────────────────────┴───────────────────────────────────┘\n   * (1): si existen dichos nodos, éstos serían el inicio y el final del camino\n   * euleriano.\n   */\n  get esEuleriano() {\n    const nodos = this.nodos;\n\n    // Condiciones que debe cumplir un grafo dirigido para contener un trayecto\n    // euleriano.\n    if (this.esDirigido) {\n      // Cualquier nodo que cumpla: GS - GE = 1.\n      let origen;\n\n      // Cantidad de nodos que cumplen: GS - GE = 1.\n      let candidatosOrigen = 0;\n\n      // Cantidad de nodos que cumplen: GE - GS = 1.\n      let candidatosDestino = 0;\n\n      for (const nodo of nodos) {\n        // GS - GE.\n        switch (this.grado(nodo, Direccion.salida) - this.grado(nodo, Direccion.entrada)) {\n          case 1:\n            candidatosOrigen++;\n            origen = nodo;\n            break;\n\n          case -1:\n            candidatosDestino++;\n            break;\n\n          // Si el nodo no cumple ninguna de las dos condiciones anteriores,\n          // necesariamente tiene que cumplir: GS - GE = 0.\n          case 0:\n            break;\n\n          // El grafo no es euleriano.\n          default:\n            return false;\n        }\n      }\n\n      // El grafo contiene sólo un nodo que cumple: GE - GS = 1 y un sólo nodo\n      // que cumple: GS - GE = 1. Por lo tanto, se cumple que el grafo\n      // contiene un camino euleriano.\n      if (candidatosOrigen === 1 && candidatosDestino === 1) {\n        return { tipo: Trayecto.camino, origen };\n      }\n\n      // En todos los nodos del grafo se cumple GE = GS. Por lo tanto, se\n      // cumple que el grafo contiene un ciclo euleriano. Además, cualquier\n      // nodo del grafo puede ser origen del ciclo euleriano.\n      return { tipo: Trayecto.ciclo, origen: first(nodos) };\n    }\n\n    // Condiciones que debe cumplir un grafo no dirigido para contener un\n    // trayecto euleriano:\n\n    // Cantidad de nodos de grado impar.\n    let impares = 0;\n\n    // Nodo impar, origen del camino euleriano.\n    let impar = 0;\n\n    // Cuenta la cantidad de nodos de grado impar del grafo. Asigna al\n    // último nodo impar como candidato a origen del camino euleriano.\n    for (const nodo of nodos) {\n      if (this.adyacentes(nodo).length % 2 === 1) {\n        impares++;\n        impar = nodo;\n      }\n    }\n\n    switch (impares) {\n      // Si todos los nodos del grafo son de grado par, entonces el grafo\n      // contiene un ciclo euleriano. En este caso, cualquier nodo puede ser\n      // el nodo origen del ciclo euleriano.\n      case 0:\n        return { tipo: Trayecto.ciclo, origen: first(nodos) };\n\n      // Si solo 2 nodos del grafo son de grado impar, entonces el grafo\n      // contiene un camino euleriano. Cualquiera de los dos nodos de grado\n      // impar puede ser el nodo origen del camino o ciclo euleriano.\n      case 2:\n        return { tipo: Trayecto.camino, origen: impar };\n\n      // No existe ningún trayecto euleriano que cubra la totalidad del grafo.\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Obtiene un trayecto euleriano, si el grafo contiene alguno.\n   *\n   * @param {Trayecto} [tipo=Trayecto.camino] - Tipo de trayecto euleriano.\n   * @returns {number[]|boolean} Trayecto euleriano, si el grafo contiene\n   * alguno, `false` en caso contrario.\n   */\n  euleriano(tipo = Trayecto.camino) {\n    /**\n     * Obtiene un trayecto euleriano de un grafo.\n     *\n     * @param {number} origen - Nodo que origina el trayecto euleriano.\n     * @returns {number[]} Trayecto euleriano del grafo.\n     *\n     * Implementación del algoritmo de Hierholzer.\n     * @see https://www-m9.ma.tum.de/graph-algorithms/hierholzer/index_en.html\n     */\n    const hierholzer = (origen) => {\n      // Trayecto euleriano.\n      let euleriano = [];\n\n      // Copia exacta del grafo, necesaria para eliminar aristas sin alterar\n      // el grafo original.\n      let grafo = cloneDeep(this);\n\n      // El algoritmo se repite hasta que todos los nodos del subtrayecto hayan\n      // sido insertados en el trayecto euleriano.\n      for (let subtrayecto = [origen]; !isEmpty(subtrayecto); ) {\n        const actual = last(subtrayecto);\n        const adyacentes = grafo.adyacentes(actual);\n\n        // Si todos los adyacentes del nodo actual han sido insertados en el\n        // subtrayecto.\n        if (isEmpty(adyacentes)) {\n          // Insertar el nodo actual al final del trayecto euleriano.\n          euleriano.push(actual);\n\n          // Eliminar el último nodo (el nodo actual) del final del subtrayecto.\n          subtrayecto.pop();\n        }\n\n        // Si aún quedan adyacentes por insertar en el subtrayecto.\n        else {\n          // Selecciona cualquier adyacente (el 1ero, por ej.).\n          const { nodo: siguiente } = first(adyacentes);\n\n          // Inserta el nodo adyacente al final del subtrayecto.\n          subtrayecto.push(siguiente);\n\n          // Elimina la arista entre el nodo actual y el nodo adyacente.\n          grafo.eliminarArista(actual, siguiente);\n        }\n      }\n\n      return euleriano.reverse();\n    };\n\n    // Obtiene el tipo de trayecto calculado, y el nodo que origina dicho\n    // trayecto.\n    const { tipo: calculado, origen } = this.esEuleriano || {};\n\n    // Si el tipo de trayecto esperado es el calculado, o si es un ciclo\n    // (incluso si se esperaba un camino), calcular el trayecto. Esta última\n    // condición se debe que, a diferencia de los trayectos hamiltonianos, un\n    // ciclo euleriano es un camino euleriano válido.\n    if (tipo === calculado || calculado === Trayecto.ciclo) {\n      return hierholzer(origen);\n    }\n\n    // No existe ningún trayecto euleriano que cubra la totalidad del grafo.\n    return false;\n  }\n\n  /**\n   * Determina si el grafo contiene un trayecto hamiltoniano.\n   *\n   * @returns {InfoTrayecto|boolean} Tipo de trayecto hamiltoniano y nodo que\n   * origina el trayecto, si existe; `false`, en caso contrario.\n   *\n   * A diferencia de los trayectos eulerianos, no existen condiciones\n   * suficientes que cumplan los grafos para determinar si existe un trayecto\n   * hamiltoniano. Esto se debe a que, tanto el problema de comprobar la\n   * existencia de un trayecto hamiltoniano, como el de encontrar dichos\n   * trayectos, son problemas NP-completos, y sus soluciones son polinómicas (y\n   * no muy eficientes).\n   */\n  get esHamiltoniano() {\n    const esCamino = Boolean(this.hamiltoniano(Trayecto.camino));\n\n    if (esCamino) {\n      return { tipo: Trayecto.camino };\n    }\n\n    const esCiclo = Boolean(this.hamiltoniano(Trayecto.ciclo));\n\n    if (esCiclo) {\n      return { tipo: Trayecto.ciclo };\n    }\n\n    // No existe ningún trayecto hamiltoniano que cubra la totalidad del grafo.\n    return false;\n  }\n\n  /**\n   * Obtiene el trayecto hamiltoniano, si el grafo contiene alguno.\n   *\n   * @param {Trayecto} [tipo=Trayecto.camino] - Tipo de trayecto hamiltoniano.\n   * @returns {number[]|boolean} Trayecto hamiltoniano, si el grafo contiene\n   * alguno, `false` en caso contrario.\n   *\n   * Encontrar cualquier trayecto hamiltoniano en un grafo es un problema\n   * NP-completo y, por lo tanto, sus soluciones no son muy eficientes. La\n   * implementación, en este caso, se realiza generando una permutación de la\n   * lista de nodos por iteración, y retornando la primera que sea un trayecto\n   * hamiltoniano válido. En el peor de los casos, la complejidad temporal de\n   * ésta implementación es O(n * n!).\n   */\n  hamiltoniano(tipo = Trayecto.camino) {\n    for (let permutacion of permutar(this.nodos)) {\n      // Si el trayecto es un ciclo, se agrega al final de la permutación el\n      // primer elemento de ésta. Así, se cumple la condicición de ciclo: el\n      // trayecto termina en el mismo nodo que lo originó.\n      if (tipo === Trayecto.ciclo) {\n        permutacion.push(first(permutacion));\n      }\n\n      if (this.esTrayecto(permutacion)) {\n        return permutacion;\n      }\n    }\n\n    // No existe ningún trayecto hamiltoniano que cubra la totalidad del grafo.\n    return false;\n  }\n\n  /**\n   * Calcula el flujo máximo desde el nodo entrada hasta el nodo salida.\n   *\n   * @param {number} entrada - Nodo entrada.\n   * @param {number} salida - Nodo salida.\n   * @returns {number} Flujo máximo desde el nodo entrada hasta el nodo salida.\n   *\n   * Implementación del algoritmo de Edmonds-Karp, que a su vez es una\n   * implementación del algoritmo de Ford-Fulkerson, utilizando búsqueda en\n   * anchura (breadth-first search, BFS).\n   */\n  flujoMaximo(entrada, salida) {\n    // Flujo máximo inicial.\n    let flujo = 0;\n\n    // Matriz de capacidad residual (peso de cada arista menos el flujo de cada\n    // camino de aumento, CA).\n    let capacidad = this.matrizDeAdyacencia;\n\n    // Se itera hasta no encontrar más caminos de aumento (CA) en el grafo.\n    // En este caso, un CA es cualquier camino simple que atraviese las aristas\n    // cuya capacidad residual sea positiva.\n    while (true) {\n      // Busca un CA en el grafo y retorna la capacidad residual mínima del CA\n      // encontrado, más la lista de padres de cada nodo que compone el CA.\n      let { flujoCamino, padre } = caminoDeAumento(this, entrada, salida, capacidad);\n\n      // Si ya no existen más CA, se termina la iteración.\n      if (flujoCamino === 0) {\n        break;\n      }\n\n      // Aumentar el flujo máximo en la cantidad de flujo del CA encontrado.\n      flujo += flujoCamino;\n\n      // Se recorre inversamente el CA (desde la salida hasta la entrada),\n      // actualizando las capacidades residuales de cada arista (y sus inversas)\n      // del CA.\n      for (let actual = salida; actual !== entrada; actual = padre[actual]) {\n        let anterior = padre[actual];\n\n        // Aumentar la capacidad residual de la arista {actual, anterior} en la\n        // capacidad residual mínima del CA.\n        capacidad[actual][anterior] += flujoCamino;\n\n        // Reducir la capacidad residual del inverso de la arista anterior en la\n        // misma cantidad que se aumentó ésta última.\n        capacidad[anterior][actual] -= flujoCamino;\n      }\n    }\n\n    return flujo;\n  }\n\n  /**\n   * @typedef {Object} ArbolGeneradorMinimo\n   *   @property {Arista[]} arbol - Lista de aristas del árbol generador mínimo.\n   *   @property {number} distancia - Distancia total del árbol generador\n   *   mínimo.\n   */\n  /**\n   * Construye un árbol generador mínimo del grafo.\n   *\n   * @returns {ArbolGeneradorMinimo} Árbol generador mínimo del grafo.\n   *\n   * Implementación del algoritmo de Kruskal, utilizando la estructura de\n   * conjuntos disjuntos.\n   */\n  get arbolGeneradorMinimo() {\n    let arbol = [];\n    let conjunto = new ConjuntoDisjunto();\n\n    // Crea un conjunto disjunto por cada nodo del grafo.\n    for (const nodo of this.nodos) {\n      conjunto.crear(nodo);\n    }\n\n    // Ordena la lista de aristas según sus pesos, ascendentemente.\n    let aristas = this.listaDeAristas.sort((a, b) => a.peso - b.peso);\n\n    for (const arista of aristas) {\n      // Se sigue la cadena de nodos padres de un nodo hasta llegar a la raíz\n      // que representa al conjunto que contiene dicho nodo.\n      const raizOrigen = conjunto.buscar(arista.origen);\n      const raizDestino = conjunto.buscar(arista.destino);\n\n      // Si la raíz del nodo origen no pertenece al mismo conjunto de la raíz\n      // del nodo destino, entonces la arista que une los nodos origen y destino\n      // no forma un ciclo con el resto de las aristas del árbol, por lo que\n      // puede ser agregada al árbol.\n      if (raizOrigen !== raizDestino) {\n        arbol.push(arista);\n\n        // Une el conjunto de la raíz del nodo origen con el conjunto de la raíz\n        // del nodo destino.\n        conjunto.unir(raizOrigen, raizDestino);\n      }\n    }\n\n    // Retorna el árbol y la distancia total del árbol (suma total de los pesos\n    // de las aristas del árbol). Si las aristas no son ponderadas, considerar\n    // peso 1 por defecto.\n    return {\n      arbol,\n      distancia: sumBy(arbol, (arista) => arista.peso ?? 1),\n    };\n  }\n}\n\nexport { Grafo, Celda, Trayecto };\n","import { Box, Button, FormControl, TextField } from '@material-ui/core';\nimport React from 'react';\nimport DeleteIcon from '@material-ui/icons/Delete';\n\n\nconst RowLink = ({ onChange, onRemove, from, to, text }) => {\n    \n    return (\n        <FormControl m={10}>\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\n                <TextField\n                    id='filled-number'\n                    label='Desde'\n                    type='number'\n                    value={from}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    InputLabelProps={{\n                        shrink: true,\n                    }}\n                    onChange={e => onChange('from', e.target.value)}\n                />\n                <TextField\n                    id='filled-number'\n                    label='Hasta'\n                    type='number'\n                    value={to}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    InputLabelProps={{\n                        shrink: true,\n                    }}\n                    onChange={e => onChange('to', e.target.value)}\n                />\n\n                <TextField\n                    id='filled-number'\n                    label='Peso'\n                    type='number'\n                    value={text}\n                    InputLabelProps={{\n                        shrink: true\n                    }}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    onChange={e => onChange( 'text', e.target.value )}\n                />\n                <Button\n                    size='small'\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\n                    onClick={onRemove}\n                >\n                </Button>\n            </Box>\n        </FormControl>\n    );\n};\n\nexport default RowLink;","import { Box, Button, FormControl, TextField } from '@material-ui/core';\nimport React from 'react';\nimport DeleteIcon from '@material-ui/icons/Delete';\n\nconst Row = ({ onChange, onRemove, text }) => {\n\n    return (\n        <FormControl className='main_formControl'>\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\n                <TextField\n                    fullWidth='true'\n                    className='main_textField'\n                    label='Nombre del nodo'\n                    value={text}\n                    onChange={e => onChange('text', e.target.value)}\n                />\n                <Button\n                    size='small'\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\n                    onClick={onRemove}\n                >\n                </Button>\n            </Box>\n        </FormControl>\n    );\n}\n\nexport default Row;","import React, { useState } from 'react';\nimport { Box, Button, TextField } from '@material-ui/core';\nimport Content from './Content';\nimport RefreshIcon from '@material-ui/icons/Refresh';\nimport { Grafo, Trayecto } from '../lib/grafo/grafo.js';\nimport { Arista } from '../lib/grafo/arista.js';\nimport { SaveAlt } from '@material-ui/icons';\nimport swal from 'sweetalert';\nimport CachedIcon from '@material-ui/icons/Cached';\nimport RowLink from './RowLink';\nimport Row from './Row';\n\nconst Main = () => {\n\n    const defaultState = {\n        text: '',\n        color: 'lightskyblue',\n    };\n\n    const defaultStateLinks = {\n        from: '',\n        to: '',\n        text: '',\n    };\n    const [rows, setRows] = useState([defaultState]); //nodos\n    const [links, setLinks] = useState([defaultStateLinks]);\n    const [doneFetch, setDoneFetch] = useState(false);\n    const [doneFetchDistance, setDoneFetchDistance] = useState(false);\n    const [doneFetchHamEul, setDoneFetchHamEul] = useState(false);\n    const [doneFetchFlujoMaximo, setDoneFetchFlujoMaximo] = useState(false);\n    const [doneFetchArbol, setDoneFetchArbol] = useState(false);\n    const [changeData, setChangeData] = useState({\n        desde: '',\n        hasta: '',\n    })\n    const [changePeakData, setChangePeakData] = useState({\n        from: '',\n        to: '',\n    });\n    const [edgesClass, setEdgesClass] = useState([]);\n    const [grafo, setGrafo] = useState([]);\n    const [arbolGenerador, setArbolGenerador] = useState([])\n    const [matrizDeCamino, setMatrizDeCamino] = useState([]);\n    const [saveAllData, setSaveAllData] = useState(false)\n    const [isHamiltoniano, setIsHamiltoniano] = useState(false);\n    const [isEuleriano, setIsEuleriano] = useState(false);\n    const [isConexo, setIsConexo] = useState(false);\n    const [distance, setDistance] = useState();\n    const [shortPath, setShortPath] = useState([]);\n    const [distanceFrom, setDistanceFrom] = useState(0);\n    const [distanceTo, setDistanceTo] = useState(0);\n    const [peakFlowFrom, setPeakFlowFrom] = useState(0);\n    const [peakFlowTo, setPeakFlowTo] = useState(0);\n    const [peakFlow, setPeakFlow] = useState();\n    const [validation, setValidation] = useState(false);\n    const [eulerianPath, setEulerianPath] = useState([]);\n    const [eulerianCycle, setEulerianCycle] = useState([]);\n    const [hamiltonianPath, setHamiltonianPath] = useState([]);\n    const [hamiltonianCycle, setHamiltonianCycle] = useState([]);\n\n    const saveArista = (from, to, peso) => {\n\n        const edge = new Arista(from, to, peso);\n        setEdgesClass(edgesClass.concat(edge));\n        grafoClass(from, to, peso)\n\n    };\n\n    const grafoClass = (from, to, peso) => {\n        const numberFrom = Number(from);\n        const numberTo = Number(to);\n        const numberPeso = Number(peso);\n        const listaDeAristas = [\n            new Arista(numberFrom, numberTo, numberPeso),\n        ];\n        setGrafo(grafo.concat(listaDeAristas));\n    };\n\n    const previewValidation = () => {\n        (rows[0].length === 0 || links[0].from.length === 0) ? (\n            swal('Campos vacíos','Para continuar con la aplicación, debes completar los campos vacíos', 'error')\n        ) : setValidation(true);\n    };\n\n    const handleArbol = () => {\n        !doneFetchArbol ? (setDoneFetchArbol(true)) : setDoneFetchArbol(false);\n    }\n\n    const handleFlujoMaximo = () => {\n        !doneFetchFlujoMaximo ? (setDoneFetchFlujoMaximo(true)) : setDoneFetchFlujoMaximo(false);\n    }\n\n    const handleDistance = () => {\n        !doneFetchDistance ? (setDoneFetchDistance(true)) : setDoneFetchDistance(false);\n\n    }\n\n    const handleHamEul = () => {\n        !doneFetchHamEul ? (setDoneFetchHamEul(true)) : setDoneFetchHamEul(false);\n    }\n\n\n\n    const handleMatriz = () => {\n        !doneFetch ? (setDoneFetch(true)) : setDoneFetch(false);\n    }\n\n\n    const saveData = () => {\n        previewValidation();\n        if(validation === true){\n            setSaveAllData(true);\n            const gra = Grafo.desdeListaDeAristas(grafo, true);\n            const { esEuleriano , esHamiltoniano, esConexo, matrizDeCaminos, arbolGeneradorMinimo: agm } = gra;\n            const { camino: shortPathGraph, distancia: distanceShortes } = gra.caminoMasCorto(distanceFrom , distanceTo);\n            const peak = gra.flujoMaximo(peakFlowFrom, peakFlowTo);\n\n            setArbolGenerador(agm.arbol.map((arista) => arista.link));\n            setMatrizDeCamino(matrizDeCaminos);\n            setIsHamiltoniano(esHamiltoniano);\n            setIsEuleriano(esEuleriano);\n            setIsConexo(esConexo);\n            setDistance(distanceShortes);\n            setShortPath(shortPathGraph);\n            setPeakFlow(peak);\n            setEulerianPath(gra.euleriano(Trayecto.camino))\n            setEulerianCycle(gra.euleriano(Trayecto.ciclo))\n            setHamiltonianPath(gra.hamiltoniano(Trayecto.camino))\n            setHamiltonianCycle(gra.hamiltoniano(Trayecto.ciclo))\n        } else console.log('error')\n\n    };\n\n    function refreshPage(e){\n        e.preventDefault()\n        window.location.reload();\n    }\n\n\n    const handleOnChange = (index, text, value) => {\n        const copyRows = [...rows];\n        const key = index;\n        copyRows[index] = {\n            ...copyRows[index],\n            key,\n            [text]: value\n        };\n        setRows(copyRows);\n    };\n\n\n    const handleOnAdd = () => {\n        let len = rows.length - 1;\n        rows[len].text.length > 0 ? setRows(rows.concat(defaultState)) : swal('Error en los nodos', 'Campos vacíos, por favor asigne nombre a los nodos creados', 'error');\n    };\n\n    const handleOnAddLink = () => {\n        let len = links.length - 1;\n        (links[len].from.length > 0 || links[len].to.length > 0 || links[len].text.length > 0 ) ? (\n            setLinks(links.concat(defaultState))\n        ) : swal('Error en los links', 'Campos vacíos en los links, por favor complete los datos antes de continuar', 'error');\n    };\n\n    const handleOnRemove = index => {\n        if(rows.length === 1){\n            swal('Error en los nodos','No se puede eliminar el único campo de nodos', 'error')\n        } else {\n            const copyRows = [...rows];\n            copyRows.splice(index, 1);\n            setRows(copyRows);\n        }\n\n        saveData();\n    };\n\n    const handleOnChangeLinks = (index, from, value, text, to) => {\n        const copyLinks = [...links];\n        copyLinks[index] = {\n            ...copyLinks[index],\n            [from]: value,\n            [to]: value,\n            [text]: value,\n        };\n        setLinks(copyLinks);\n        if (copyLinks[index].from && copyLinks[index].to && copyLinks[index].text)\n            saveArista(copyLinks[index].from, copyLinks[index].to, copyLinks[index].text)\n    };\n\n    const handleOnRemoveLink = index => {\n        if(links.length === 1){\n            swal(\"Error en los links\", 'No se puede eliminar el único elemento de los links', 'error')\n        } else {\n            const copyLinks = [...links];\n            copyLinks.splice(index, 1);\n            setLinks(copyLinks);\n        }\n        saveData();\n    };\n\n    const handleSubmitFromTo = (e) => {\n        e.preventDefault();\n        getFromTo(changeData)\n    };\n\n    const handleInputChangeFromTo = (e) => {\n        e.preventDefault();\n        setChangeData({\n            ...changeData,\n            [e.target.name]: e.target.value,\n        })\n    };\n\n    const handleSubmitPeak = (e) => {\n        e.preventDefault();\n        peakFlowFromTo(changePeakData);\n    };\n\n    const peakFlowFromTo = ({from, to}) => {\n        if( from && to ){\n            setPeakFlowFrom(Number(from));\n            setPeakFlowTo(Number(to));\n        }\n\n    };\n\n    const getFromTo = ({desde, hasta}) => {\n        if(desde && hasta){\n            setDistanceFrom(Number(desde));\n            setDistanceTo(Number(hasta));\n        }\n    };\n\n    const handleInputPeakFlow = (e) => {\n        e.preventDefault();\n        setChangePeakData({\n            ...changePeakData,\n            [e.target.name]: e.target.value,\n        })\n    };\n\n    return (\n        <Box display='flex' className='main_view'>\n            <div className='main_options'>\n                <Button m={10} variant='contained' color='secondary' onClick={handleOnAdd}>Agregar</Button>\n                {rows.map((row, index) => (\n\n                    <Row\n                        {...row}\n                        className='main_row'\n                        onChange={(text, value) => handleOnChange(index, text, value)}\n                        onRemove={() => handleOnRemove(index)}\n                        key={index}\n                    />\n                ))}\n\n                <hr />\n                <Button m={10} variant='contained' color='grey' onClick={handleOnAddLink}>Agregar link</Button>\n                {links.map((link, index) => (\n                    <RowLink\n                        {...link}\n                        className='main_row'\n                        onChange={(from, to, value, text) => handleOnChangeLinks(index, from, to, value, text)}\n                        onRemove={() => handleOnRemoveLink(index)}\n                        key={index}\n                    />\n                ))}\n\n                <div>\n                    {\n                        (links.length < 1 || rows.length < 1 ) ? (\n                            <Button m={10}\n                                className='main_row'\n                                variant='contained'\n                                color='primary'\n                                disabled\n                            >\n                                GUARDAR DATOS\n                                <SaveAlt/>\n                            </Button>\n                        ) : (\n                            <Button m={10}\n                                className='main_row'\n                                variant='contained'\n                                color='primary'\n                                onClick={saveData}\n                            >\n                                GUARDAR DATOS\n                                <SaveAlt />\n                            </Button>\n                        )\n                    }\n                </div>\n\n{/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleMatriz}\n                            disabled\n                        >\n                            MATRIZ DE CAMINO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleMatriz}\n                        >\n                            MATRIZ DE CAMINO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetch === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <Button\n                        variant='contained'\n                        color='gray'\n                        type='submit'\n                        className=\"main_buttonMargin\"\n                    ><RefreshIcon />\n                    </Button>\n                    <div className=\"item\">\n\n                    {\n                        matrizDeCamino &&\n                            matrizDeCamino.map((item, index) => (\n                                <div className=\"main_boxItem\">\n                                    <p>{index}</p>\n                                    {\n\n                                        item.map(miniItem => (\n                                            <div className=\"main_boxMiniItem\">\n                                                <p className='main_p'>{miniItem} &nbsp; </p>\n                                            </div>\n                                        ))\n\n                                    }\n                                </div>\n                            ))\n                    }\n                    <p className='main_isConexo'>\n                        {\n                            (isConexo===true) ? ('El grafo es conexo') : ('El grafo no es conexo')\n                        }\n                    </p>\n                    </div>\n                </div >\n{/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\n\n\n{/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleDistance}\n                            disabled\n                        >\n                            DISTANCIA ENTRE DOS NODOS\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleDistance}\n\n                        >\n                            DISTANCIA ENTRE DOS NODOS\n                        </Button>\n                    )\n                }\n\n                <div\n                    className={\n                        doneFetchDistance === true ? ('main_isMatriz') : 'main_noMatriz'\n                    }>\n                    <form className='main_formDistance' onSubmit={handleSubmitFromTo}>\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number'\n                            label='Desde'\n                            type='number'\n                            name='desde'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputChangeFromTo}\n                            InputLabelProps={{\n                                shrink: true,\n                            }}\n                        />\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number'\n                            label='Hasta'\n                            type='number'\n                            name='hasta'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputChangeFromTo}\n                            InputLabelProps={{ shrink: true, }}\n                        />\n\n                        <Button\n                            variant='contained'\n                            color='primary'\n                            type='submit'\n                            onClick={saveData}\n                        ><RefreshIcon />\n                        </Button>\n                    </form>\n                    {\n                        changeData.desde && changeData.hasta ? (\n                            <div className='distanceFromTo'>\n                                <p>Los nodos recorridos son los siguientes: </p>\n                                {shortPath.map(item => (\n                                    <p className='main_distanceItem'>{item}</p>\n                                ))}\n                            <p>\n                                Distancia : {distance}\n                            </p>\n                            </div>\n                        ) : console.log()\n                    }\n\n                </div >\n{/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\n\n{/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleHamEul}\n                            disabled\n                        >\n                            HAMILTONIANO Y/O EULERIANO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleHamEul}\n                        >\n                            HAMILTONIANO Y/O EULERIANO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchHamEul === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <div className='distanceFromTo'>\n                    <p>\n                        {\n                            !isHamiltoniano ? ('El grafo no es hamiltoniano') : ('El grafo es hamiltoninao')\n                        }\n\n                        {\n                            hamiltonianCycle ? (\n                                <>\n                                    <p>Tiene como ciclo: </p>\n                                    {\n                                        hamiltonianCycle.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(hamiltonianCycle)\n                        }\n\n{\n                            hamiltonianPath ? (\n                                <>\n                                    <p>Tiene como camino: </p>\n                                    {\n                                        hamiltonianPath.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(hamiltonianPath)\n                        }\n\n                    </p>\n                    <p>\n                        {\n                            !isEuleriano ? ('El grafo no es euleriano') : ('El grano es euleriano')\n                        }\n\n{\n                            eulerianCycle ? (\n                                <>\n                                    <p>Tiene como ciclo: </p>\n                                    {\n                                        eulerianCycle.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(eulerianCycle)\n                        }\n\n{\n                            eulerianPath ? (\n                                <>\n                                    <p>Tiene como camino: </p>\n                                    {\n                                        eulerianPath.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(eulerianPath)\n                        }\n                    </p>\n                    </div>\n                </div >\n{/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\n\n\n{/* ------------------------ FLUJO MÁXIMO ------------------------ */}\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleFlujoMaximo}\n                            disabled\n                        >\n                            FLUJO MÁXIMO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleFlujoMaximo}\n                        >\n                            FLUJO MÁXIMO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchFlujoMaximo === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <form className='main_formDistance' onSubmit={handleSubmitPeak}>\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number-peak'\n                            label='Desde'\n                            type='number'\n                            name='from'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputPeakFlow}\n                            InputLabelProps={{\n                                shrink: true,\n                            }}\n                        />\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number-peak'\n                            label='Hasta'\n                            type='number'\n                            name='to'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputPeakFlow}\n                            InputLabelProps={{ shrink: true, }}\n                        />\n                        <Button\n                            variant='contained'\n                            color='gray'\n                            type='submit'\n                            onClick={saveData}\n                        ><RefreshIcon />\n                        </Button>\n                    </form>\n                    {\n                        changePeakData.from && changePeakData.to ? (\n                            <div className='distanceFromTo'>\n                                <p>Flujo máximo es: {peakFlow}</p>\n                            </div>\n                        ) : (\n                            <div className='distanceFromTo'>\n                                <p>Flujo máximo resultante es: {peakFlow}</p>\n                            </div>\n                        )\n                    }\n                </div >\n\n{/* ------------------------ FLUJO MÁXIMO ------------------------ */}\n\n{/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\n                {\n                    !saveAllData ? (\n                        <Button\n                            m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleArbol}\n                            disabled\n                        >\n                            ÁRBOL GENERADOR\n                        </Button>\n                    ) : (\n                        <Button\n                            m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleArbol}\n                        >\n                            ÁRBOL GENERADOR\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchArbol === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <Button\n                        variant='contained'\n                        color='gray'\n                        type='submit'\n                    ><RefreshIcon />\n                    </Button>\n                    <div className='main_contentInside'>\n                        {\n                            arbolGenerador &&\n                            <Content className=\"hola\" data={rows} linksData={arbolGenerador} />\n                        }\n                    </div>\n                </div >\n\n{/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\n\n            <Button type=\"button\" onClick={ refreshPage }> Recargar la página <span><CachedIcon className='main_reloadIcon' /></span> </Button>\n\n            </div >\n\n\n\n\n            <Content data={rows} linksData={links} />\n        </Box >\n    )\n}\n\n\nexport default Main;\n","import React from 'react';\nimport { AppBar, Toolbar } from '@material-ui/core'\nimport { Link } from 'react-router-dom';\nconst Header = () => (\n    <AppBar position='static'>\n        <Toolbar className='header_header'>\n            <Link to='/'>\n                <h3 className='header_title'>App Grafos</h3>\n            </Link>\n            <div className='initalPage_item'>\n                <Link to='/documentacion'>\n                    DOCUMENTACIÓN\n                </Link>\n            </div>\n            \n        </Toolbar>\n\n\n    </AppBar>\n\n)\n\nexport default Header;\n","import React from 'react';\nimport * as go from 'gojs';\nimport { ReactDiagram } from 'gojs-react';\n\n\nfunction initDiagram() {\n  const $ = go.GraphObject.make;\n  const diagram =\n    $(go.Diagram,\n      {\n        'undoManager.isEnabled': true,\n        'clickCreatingTool.archetypeNodeData': { text: 'new node', color: 'lightblue', fig: 'Cloud' },\n        model: $(go.GraphLinksModel,\n          {\n            linkKeyProperty: 'key'\n          })\n      });\n\n  diagram.nodeTemplate =\n    $(go.Node, 'Auto',  // the Shape will go around the TextBlock\n      new go.Binding(),\n      $(go.Shape, 'Circle',\n        { name: 'SHAPE', fill: 'white', strokeWidth: 1, portId: \"\" },\n        // Shape.fill is bound to Node.data.color\n        new go.Binding('fill', 'color')),\n      $(go.TextBlock,\n        { margin: 20, editable: false, font: \"30px Verdana\" },\n        new go.Binding('text').makeTwoWay()\n      )\n    );\n\n  diagram.linkTemplate =\n    $(go.Link,\n      { curve: go.Link.Bezier },\n      $(go.Shape),\n      $(go.Shape, { toArrow: \"Standard\" }),\n      $(go.TextBlock,\n        { font: \"30px Verdana\" },                     \n        new go.Binding(\"text\", \"text\"))\n    );\n\n\n  diagram.linkTemplate =\n    $(go.Link,\n      $(go.Shape)\n    );\n\n  return diagram;\n}\n\n\nconst NotDirected = ({ data, linksData }) => {\n  return (\n    <div className=\"content\">\n      <ReactDiagram\n        initDiagram={initDiagram}\n        divClassName='diagram-component'\n        nodeDataArray={data}\n        linkDataArray={linksData}\n      />\n    </div>\n  )\n}\nexport default NotDirected;","import React, { useState } from 'react';\nimport { Box, Button, FormControl, TextField } from '@material-ui/core';\nimport DeleteIcon from '@material-ui/icons/Delete';\nimport RefreshIcon from '@material-ui/icons/Refresh';\nimport { Grafo, Trayecto } from '../lib/grafo/grafo.js';\nimport { Arista } from '../lib/grafo/arista.js';\nimport { SaveAlt } from '@material-ui/icons';\nimport swal from 'sweetalert';\nimport CachedIcon from '@material-ui/icons/Cached';\nimport NotDirected from './NotDirected.js';\n\nfunction Row({ onChange, onRemove, text }) {\n\n    return (\n        <FormControl className='main_formControl'>\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\n                <TextField\n                    fullWidth='true'\n                    className='main_textField'\n                    label='Nombre del nodo'\n                    value={text}\n                    onChange={e => onChange('text', e.target.value)}\n                />\n                <Button\n                    size='small'\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\n                    onClick={onRemove}\n                >\n                </Button>\n            </Box>\n        </FormControl>\n    );\n}\n\nfunction RowLink({ onChange, onRemove, from, to, text }) {\n\n    return (\n        <FormControl m={10}>\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\n                <TextField\n                    id='filled-number'\n                    label='Desde'\n                    type='number'\n                    value={from}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    InputLabelProps={{\n                        shrink: true,\n                    }}\n                    onChange={e => onChange('from', e.target.value)}\n                />\n                <TextField\n                    id='filled-number'\n                    label='Hasta'\n                    type='number'\n                    value={to}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    InputLabelProps={{\n                        shrink: true,\n                    }}\n                    onChange={e => onChange('to', e.target.value)}\n                />\n\n                <TextField\n                    id='filled-number'\n                    label='Peso'\n                    type='number'\n                    value={text}\n                    InputLabelProps={{\n                        shrink: true\n                    }}\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\n                    onChange={e => onChange( 'text', e.target.value )}\n                />\n                <Button\n                    size='small'\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\n                    onClick={onRemove}\n                >\n                </Button>\n            </Box>\n        </FormControl>\n    );\n}\n\nconst MainNotDirected = () => {\n\n    const defaultState = {\n        text: '',\n        color: 'lightskyblue',\n    };\n\n    const defaultStateLinks = {\n        from: '',\n        to: '',\n        text: '',\n    };\n    const [rows, setRows] = useState([defaultState]); //nodos\n    const [links, setLinks] = useState([defaultStateLinks]);\n    const [doneFetch, setDoneFetch] = useState(false);\n    const [doneFetchDistance, setDoneFetchDistance] = useState(false);\n    const [doneFetchHamEul, setDoneFetchHamEul] = useState(false);\n    const [doneFetchFlujoMaximo, setDoneFetchFlujoMaximo] = useState(false);\n    const [doneFetchArbol, setDoneFetchArbol] = useState(false);\n    const [changeData, setChangeData] = useState({\n        desde: '',\n        hasta: '',\n    })\n    const [changePeakData, setChangePeakData] = useState({\n        from: '',\n        to: '',\n    });\n    // Creando aristas usando la clase Arista\n    const [edgesClass, setEdgesClass] = useState([]);\n    const [grafo, setGrafo] = useState([]);\n    const [arbolGenerador, setArbolGenerador] = useState([])\n    const [matrizDeCamino, setMatrizDeCamino] = useState([]);\n    const [saveAllData, setSaveAllData] = useState(false)\n    const [isHamiltoniano, setIsHamiltoniano] = useState(false);\n    const [isEuleriano, setIsEuleriano] = useState(false);\n    const [isConexo, setIsConexo] = useState(false);\n    //camino más corto\n    const [distance, setDistance] = useState();\n    const [shortPath, setShortPath] = useState([]);\n    const [distanceFrom, setDistanceFrom] = useState(0);\n    const [distanceTo, setDistanceTo] = useState(0);\n    const [peakFlowFrom, setPeakFlowFrom] = useState(0);\n    const [peakFlowTo, setPeakFlowTo] = useState(0);\n    const [peakFlow, setPeakFlow] = useState();\n    const [validation, setValidation] = useState(false);\n    const [eulerianPath, setEulerianPath] = useState([]);\n    const [eulerianCycle, setEulerianCycle] = useState([]);\n    const [hamiltonianPath, setHamiltonianPath] = useState([]);\n    const [hamiltonianCycle, setHamiltonianCycle] = useState([]);\n\n    const saveArista = (from, to, peso) => {\n\n        const edge = new Arista(from, to, peso);\n        setEdgesClass(edgesClass.concat(edge));\n        grafoClass(from, to, peso)\n\n    };\n\n    // grafoClass => función para poder crear\n    const grafoClass = (from, to, peso) => {\n        const numberFrom = Number(from);\n        const numberTo = Number(to);\n        const numberPeso = Number(peso);\n\n        const listaDeAristas = [\n            new Arista(numberFrom, numberTo, numberPeso),\n        ];\n        setGrafo(grafo.concat(listaDeAristas));\n    };\n\n    const previewValidation = () => {\n\n        if(rows[0].length === 0 || links[0].from.length === 0){\n            swal('Campos vacíos','Para continuar con la aplicación, debes completar los campos vacíos', 'error')\n        }\n        else {\n            setValidation(true);\n        }\n    }\n\n\n    const saveData = () => {\n\n        previewValidation();\n\n\n        if(validation === true){\n\n            setSaveAllData(true);\n            // Implementanción del grafo\n            const gra = Grafo.desdeListaDeAristas(grafo, false);\n            const { esEuleriano , esHamiltoniano, esConexo, matrizDeCaminos, arbolGeneradorMinimo: agm } = gra;\n            const { camino: shortPathGraph, distancia: distanceShortes } = gra.caminoMasCorto(distanceFrom , distanceTo);\n            const peak = gra.flujoMaximo(peakFlowFrom, peakFlowTo);\n\n            setArbolGenerador(agm.arbol.map((arista) => arista.link));\n            setMatrizDeCamino(matrizDeCaminos);\n            setIsHamiltoniano(esHamiltoniano);\n            setIsEuleriano(esEuleriano);\n            setIsConexo(esConexo);\n            setDistance(distanceShortes);\n            setShortPath(shortPathGraph);\n            setPeakFlow(peak);\n            setEulerianPath(gra.euleriano(Trayecto.camino))\n            setEulerianCycle(gra.euleriano(Trayecto.ciclo))\n            setHamiltonianPath(gra.hamiltoniano(Trayecto.camino))\n            setHamiltonianCycle(gra.hamiltoniano(Trayecto.ciclo))\n        }\n\n    };\n\n    function refreshPage(e){\n        e.preventDefault()\n        window.location.reload();\n    }\n\n    const handleArbol = () => {\n        !doneFetchArbol ? (setDoneFetchArbol(true)) : setDoneFetchArbol(false);\n    };\n\n    const handleFlujoMaximo = () => {\n        !doneFetchFlujoMaximo ? (setDoneFetchFlujoMaximo(true)) : setDoneFetchFlujoMaximo(false);\n    };\n\n    const handleDistance = () => {\n        !doneFetchDistance ? (setDoneFetchDistance(true)) : setDoneFetchDistance(false);\n\n    };\n\n    const handleHamEul = () => {\n        !doneFetchHamEul ? (setDoneFetchHamEul(true)) : setDoneFetchHamEul(false);\n    };\n\n    const handleMatriz = () => {\n        !doneFetch ? (setDoneFetch(true)) : setDoneFetch(false);\n    };\n\n    const handleOnChange = (index, text, value) => {\n        const copyRows = [...rows];\n        const key = index;\n        copyRows[index] = {\n            ...copyRows[index],\n            key,\n            [text]: value\n        };\n        setRows(copyRows);\n    };\n\n\n    const handleOnAdd = () => {\n        let len = rows.length - 1;\n        rows[len].text.length > 0 ? (setRows(rows.concat(defaultState))) : swal('Error en los nodos', 'Campos vacíos, por favor asigne nombre a los nodos creados', 'error');\n    };\n\n    const handleOnAddLink = () => {\n        let len = links.length - 1;\n        (links[len].from.length > 0 || links[len].to.length > 0 || links[len].text.length > 0 ) ? (\n            setLinks(links.concat(defaultState))\n        ) : swal('Error en los links', 'Campos vacíos en los links, por favor complete los datos antes de continuar', 'error');\n    };\n\n    const handleOnRemove = index => {\n        if(rows.length === 1){\n            swal('Error en los nodos','No se puede eliminar el único campo de nodos', 'error')\n        } else {\n            const copyRows = [...rows];\n            copyRows.splice(index, 1);\n            setRows(copyRows);\n        }\n\n        saveData();\n        console.log(saveData)\n    };\n\n    const handleOnChangeLinks = (index, from, value, text, to) => {\n        // links cambios agregar\n        const copyLinks = [...links];\n        copyLinks[index] = {\n            ...copyLinks[index],\n            [from]: value,\n            [to]: value,\n            [text]: value,\n        };\n        setLinks(copyLinks);\n        //Guardar en clase\n        if (copyLinks[index].from && copyLinks[index].to && copyLinks[index].text)\n            saveArista(copyLinks[index].from, copyLinks[index].to, copyLinks[index].text)\n    };\n\n    const handleOnRemoveLink = index => {\n        if(links.length === 1){\n            swal(\"Error en los links\", 'No se puede eliminar el único elemento de los links', 'error')\n        } else {\n            const copyLinks = [...links];\n            copyLinks.splice(index, 1);\n            setLinks(copyLinks);\n        }\n        saveData();\n        console.log('2')\n    };\n\n\n    // Obtener valores desde y hasta para implementar Dijkstra\n\n    const handleSubmitFromTo = (e) => {\n        e.preventDefault();\n        getFromTo(changeData)\n    };\n\n    const handleInputChangeFromTo = (e) => {\n        e.preventDefault();\n        setChangeData({\n            ...changeData,\n            [e.target.name]: e.target.value,\n        })\n\n    }\n\n    const getFromTo = ({desde, hasta}) => {\n        if(desde && hasta){\n            setDistanceFrom(Number(desde));\n            setDistanceTo(Number(hasta));\n        }\n    }\n\n    // Enviar changeData para actualizar formulario\n    const peakFlowFromTo = ({from, to}) => {\n        if(from && to ){\n            setPeakFlowFrom(Number(from));\n            setPeakFlowTo(Number(to));\n        }\n\n    }\n\n\n    const handleInputPeakFlow = (e) => {\n        e.preventDefault();\n        setChangePeakData({\n            ...changePeakData,\n            [e.target.name]: e.target.value,\n        })\n\n    }\n\n    const handleSubmitPeak = (e) => {\n        e.preventDefault();\n        peakFlowFromTo(changePeakData);\n    };\n\n\n\n\n    return (\n        <Box display='flex' className='main_view'>\n            <div className='main_options'>\n                <Button m={10} variant='contained' color='secondary' onClick={handleOnAdd}>Agregar</Button>\n                {rows.map((row, index) => (\n\n                    <Row\n                    {...row}\n                    className='main_row'\n                    onChange={(text, value) => handleOnChange(index, text, value)}\n                    onRemove={() => handleOnRemove(index)}\n                    key={index}\n                    />\n                ))}\n\n                <hr />\n                <Button m={10} variant='contained' color='grey' onClick={handleOnAddLink}>Agregar link</Button>\n                {links.map((link, index) => (\n                    <RowLink\n                        {...link}\n                        className='main_row'\n                        onChange={(from, to, value, text) => handleOnChangeLinks(index, from, to, value, text)}\n                        onRemove={() => handleOnRemoveLink(index)}\n                        key={index}\n                    />\n                ))}\n\n                <div>\n\n                    {\n                        (links.length < 1 || rows.length < 1 ) ? (\n                            <Button m={10}\n                                className='main_row'\n                                variant='contained'\n                                color='primary'\n                                disabled\n                            >\n                                GUARDAR DATOS\n                                <SaveAlt/>\n                            </Button>\n                        ) : (\n                            <Button m={10}\n                                className='main_row'\n                                variant='contained'\n                                color='primary'\n                                onClick={saveData}\n                            >\n                                GUARDAR DATOS\n                                <SaveAlt />\n                            </Button>\n                        )\n                    }\n                </div>\n\n{/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleMatriz}\n                            disabled\n                        >\n                            MATRIZ DE CAMINO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleMatriz}\n                        >\n                            MATRIZ DE CAMINO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetch === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <Button\n                        variant='contained'\n                        color='gray'\n                        type='submit'\n                        className=\"main_buttonMargin\"\n                    ><RefreshIcon />\n                    </Button>\n                    <div className=\"item\">\n\n                    {\n                        matrizDeCamino &&\n                            matrizDeCamino.map((item, index) => (\n                                <div className=\"main_boxItem\">\n                                    <p>{index}</p>\n                                    {\n\n                                        item.map(miniItem => (\n                                            <div className=\"main_boxMiniItem\">\n                                                <p className='main_p'>{miniItem} &nbsp; </p>\n                                            </div>\n                                        ))\n\n                                    }\n                                </div>\n                            ))\n                    }\n                    <p className='main_isConexo'>\n                        {\n                            (isConexo===true) ? ('El grafo es conexo') : ('El grafo no es conexo')\n                        }\n                    </p>\n                    </div>\n                </div >\n{/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\n\n\n{/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleDistance}\n                            disabled\n                        >\n                            DISTANCIA ENTRE DOS NODOS\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleDistance}\n\n                        >\n                            DISTANCIA ENTRE DOS NODOS\n                        </Button>\n                    )\n                }\n\n                <div\n                    className={\n                        doneFetchDistance === true ? ('main_isMatriz') : 'main_noMatriz'\n                    }>\n                    <form className='main_formDistance' onSubmit={handleSubmitFromTo}>\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number'\n                            label='Desde'\n                            type='number'\n                            name='desde'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputChangeFromTo}\n                            InputLabelProps={{\n                                shrink: true,\n                            }}\n                        />\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number'\n                            label='Hasta'\n                            type='number'\n                            name='hasta'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputChangeFromTo}\n                            InputLabelProps={{ shrink: true, }}\n                        />\n\n                        <Button\n                            variant='contained'\n                            color='primary'\n                            type='submit'\n                            onClick={saveData}\n                        ><RefreshIcon />\n                        </Button>\n                    </form>\n                    {\n                        changeData.desde && changeData.hasta ? (\n                            <div className='distanceFromTo'>\n                                <p>Los nodos recorridos son los siguientes: </p>\n                                {shortPath.map(item => (\n                                    <p className='main_distanceItem'>{item}</p>\n                                ))}\n                            <p>\n                                Distancia : {distance}\n                            </p>\n                            </div>\n                        ) : console.log()\n                    }\n\n                </div >\n{/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\n\n{/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\n\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleHamEul}\n                            disabled\n                        >\n                            HAMILTONIANO Y/O EULERIANO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleHamEul}\n                        >\n                            HAMILTONIANO Y/O EULERIANO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchHamEul === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <div className='distanceFromTo'>\n                    <p>\n                        {\n                            !isHamiltoniano ? ('El grafo no es hamiltoniano') : ('El grafo es hamiltoninao')\n                        }\n\n                        {\n                            hamiltonianCycle ? (\n                                <>\n                                    <p>Tiene como ciclo: </p>\n                                    {\n                                        hamiltonianCycle.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(hamiltonianCycle)\n                        }\n\n{\n                            hamiltonianPath ? (\n                                <>\n                                    <p>Tiene como camino: </p>\n                                    {\n                                        hamiltonianPath.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(hamiltonianPath)\n                        }\n\n                    </p>\n                    <p>\n                        {\n                            !isEuleriano ? ('El grafo no es euleriano') : ('El grano es euleriano')\n                        }\n\n{\n                            eulerianCycle ? (\n                                <>\n                                    <p>Tiene como ciclo: </p>\n                                    {\n                                        eulerianCycle.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(eulerianCycle)\n                        }\n\n{\n                            eulerianPath ? (\n                                <>\n                                    <p>Tiene como camino: </p>\n                                    {\n                                        eulerianPath.map(item => (\n                                            <p className='main_pathOrCycle'> {item} </p>\n                                        ))\n                                    }\n                                </>\n\n                            ) : console.log(eulerianPath)\n                        }\n                    </p>\n                    </div>\n                </div >\n{/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\n\n\n{/* ------------------------ FLUJO MÁXIMO ------------------------ */}\n                {\n                    !saveAllData ? (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleFlujoMaximo}\n                            disabled\n                        >\n                            FLUJO MÁXIMO\n                        </Button>\n                    ) : (\n                        <Button m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleFlujoMaximo}\n                        >\n                            FLUJO MÁXIMO\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchFlujoMaximo === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <form className='main_formDistance' onSubmit={handleSubmitPeak}>\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number-peak'\n                            label='Desde'\n                            type='number'\n                            name='from'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputPeakFlow}\n                            InputLabelProps={{\n                                shrink: true,\n                            }}\n                        />\n                        <TextField\n                            className='main_textFieldDistance'\n                            id='filled-number-peak'\n                            label='Hasta'\n                            type='number'\n                            name='to'\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\n                            onChange={handleInputPeakFlow}\n                            InputLabelProps={{ shrink: true, }}\n                        />\n                        <Button\n                            variant='contained'\n                            color='gray'\n                            type='submit'\n                            onClick={saveData}\n                        ><RefreshIcon />\n                        </Button>\n                    </form>\n                    {\n                        changePeakData.from && changePeakData.to ? (\n                            <div className='distanceFromTo'>\n                                <p>Flujo máximo es: {peakFlow}</p>\n                            </div>\n                        ) : (\n                            <div className='distanceFromTo'>\n                                <p>Flujo máximo resultante es: {peakFlow}</p>\n                            </div>\n                        )\n                    }\n                </div >\n\n{/* ------------------------ FLUJO MÁXIMO ------------------------ */}\n\n{/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\n                {\n                    !saveAllData ? (\n                        <Button\n                            m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleArbol}\n                            disabled\n                        >\n                            ÁRBOL GENERADOR\n                        </Button>\n                    ) : (\n                        <Button\n                            m={10}\n                            className='main_row'\n                            variant='contained'\n                            color='primary'\n                            onClick={handleArbol}\n                        >\n                            ÁRBOL GENERADOR\n                        </Button>\n                    )\n                }\n\n                <div className={\n                    doneFetchArbol === true ? ('main_isMatriz') : 'main_noMatriz'\n                }>\n                    <Button\n                        variant='contained'\n                        color='gray'\n                        type='submit'\n                    ><RefreshIcon />\n                    </Button>\n                    <div className='main_contentInside'>\n                        {\n                            arbolGenerador &&\n                            <NotDirected className=\"hola\" data={rows} linksData={arbolGenerador} />\n                        }\n                    </div>\n                </div >\n\n{/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\n\n            <Button type=\"button\" onClick={ refreshPage }> Recargar la página <span><CachedIcon className='main_reloadIcon' /></span> </Button>\n\n            </div >\n\n\n\n\n            <NotDirected data={rows} linksData={links} />\n        </Box >\n    )\n}\n\n\nexport default MainNotDirected;\n","import React from 'react'\nimport { Link } from 'react-router-dom'\n\nconst InitialPage = () => {\n    return (\n        <div className='initialPage_container'>\n            <div className='initalPage_item'>\n                <Link to='/dirigido'>\n                    DIRIGIDO\n            </Link>\n            </div>\n            <div className='initalPage_item'>\n                <Link to='/no-dirigido'>\n                    NO DIRIGIDO\n            </Link>\n            </div>\n\n            <div className='initalPage_item'>\n                <Link to='/documentacion'>\n                    DOCUMENTACIÓN\n                </Link>\n            </div>\n\n        </div>\n    )\n}\n\nexport default InitialPage;\n","export default __webpack_public_path__ + \"static/media/doc-ex.89254a2c.PNG\";","export default __webpack_public_path__ + \"static/media/link-ex.35ce9f1d.PNG\";","export default __webpack_public_path__ + \"static/media/graph.e7666be6.PNG\";","import React from 'react';\nimport DocEx from '../assets/img/doc-ex.PNG';\nimport LinkEx from '../assets/img/link-ex.PNG';\nimport Graph from '../assets/img/graph.PNG';\nimport { Link } from 'react-router-dom';\n\nconst Documentation = () => {\n    return (\n        <div className='documentation_container'>\n            <h2>Documentación de aplicación de grafos</h2>\n            <p>A continuación encontrarás la documentación de nuestra aplicación de grafos además de una serie de recomendaciones para que\n            tu experiencia dentro de la aplicación sea la más grata posible.\n            </p>\n            <h3>Recomendación inicial</h3>\n            <ul>\n                <p>Por motivos de la librería que utilizamos para el desarrollo y trabajo de nodos, estos\n                deben trabajarse como si fuesen referenciados desde índice 0, independiente del nombre que\n                posean. A continuación de mostrará un ejemplo de implementación:\n                </p>\n            </ul>\n            <div className='documentation_ex'>\n                <img src={DocEx} alt='Ejemplificación de nombre' />\n                <p className='documentation_info'>Dada la imagen anterior, sumado a la información anterior, debemos concluir\n                que <span className='spanBlack'> el nodo llamado &quot;Primer nodo&quot; tendrá como referencia el número &quot;0&quot;.</span> Por consiguiente, el nodo\n                llamado &quot;Segundo nodo&quot; tendrá asignado el número &quot;1&quot;. Finalmente, los nodos &quot;Tercer\n                nodo&quot; y &quot;Cuarto nodo&quot; tendrán asignados los valores &quot;2&quot; y &quot;3&quot;, respectivamente.\n                </p>\n            </div>\n            <ul>\n                Por lo tanto, si queremos unir los nodos anteriormente planteados, debemos hacerlo de la siguiente manera:\n            </ul>\n            <div className='documentation_ex'>\n                <img src={LinkEx} alt='Ejemplificación de links' />\n                <p className='documentation_info'>y obtenemos ... </p>\n                <img src={Graph} alt='Grafo final' />\n            </div>\n            <ul>\n                Finalmente, para que tu experiencia dentro de la aplicación sea la mejor, <span className='spanBlack'>te recomendamos trabajar los nodos con nombres\n                que inicien desde el 0 hacia delante</span>. Sin embargo, puedes colocar cualquier nombre que desees y puedes editarlo en cualquier momento\n                pero debes tener siempre en cuenta el ejemplo anterior.\n            </ul>\n            <h3>Limitaciones</h3>\n            <ul>\n                <li>\n                    Nuestra aplicación está pensada para ser trabajada desde computadores o pantallas de grandes dimensiones,\n                    motivo por el cual <span className='spanBlack'>nuestro programa no es responsive</span>, es decir, no es adaptable a dispositivos más pequeños\n                    al anteriormente mencionado.\n                </li>\n            </ul>\n            <h3>Comandos</h3>\n            <ul>\n                <li>\n                    Si deseas agrandar o disminuir el tamaño de los nodos, solo debes usar la tecla <span className='spanBlack'>CTRL</span> y usar la rueda del mouse o el botón \n                    <span className='spanBlack'> +</span> o <span className='spanBlack'>-</span>\n                </li>\n            </ul>\n            <h3>Páginas</h3>\n            <p>Nuestra aplicación cuenta con 3 secciones además de esta:</p>\n            <ul>\n                <li>\n                    <Link to='/'>\n                        Página inicial\n                    </Link >\n                    <p>Página inicial de la aplicación, aquí podrás escoger entre trabajar con grafos dirigidos o no dirigidos</p>\n                </li>\n                <li>\n                    <Link to='/dirigidos'>\n                        Página para grafos dirigidos\n                    </Link >\n                    <p>Página para trabajar con grafos dirigidos</p>\n\n                </li>\n                <li>\n                    <Link to='/no-dirigidos'>\n                        Página para grafos no dirigidos\n                </Link >\n                <p>Página para trabajar con grafos no dirigidos</p>\n\n                </li>\n            </ul>\n            <h3>Errores y alertas</h3>\n            <ul>\n                <li>\n                    En caso de realizar alguna acción que no se encuentre permitida, nuestra aplicación está diseñada para <span className='spanBlack'>indicarte el error\n                    además de la ubicación del mismo junto a su respectiva solución.</span>\n                </li>\n\n            </ul>\n            <h3>Secciones</h3>\n            <ul>\n                <li className='spanBlue'>Matríz de camino</li>\n                <p>Podrás visualizar una matriz de caminos y verificar si el grafo ingresado es o no conexo.</p>\n                <li className='spanBlue'>Distancia entre dos nodos</li>\n                <p>Mostrará el recorrido que hay entre dos nodos además de la distancia entre los mismos.</p>\n                <li className='spanBlue'>Euleriano y/o hamiltoniano</li>\n                <p>Determinará si un grafo es Euleriano y/o Hamiltoniano. Por otra parte, mostrará el camino o ciclo en caso de que exista.</p>\n                <li className='spanBlue'>Flujo máximo</li>\n                <p>Determina el flujo máximo que hay entre dos nodos.</p>\n                <li className='spanBlue'>Árbol generador</li>\n                <p>Podrás ver el árbol que se genera a causa del grafo. Tienes la libertad de mover los nodos como gustes dentro de el contenedor.</p>\n            </ul>\n\n            <h3>Tecnologías usadas</h3>\n            <ul>\n                <li>\n                    <a href='https://es.reactjs.org/'>\n                        React JS\n                    </a>\n                </li>\n                <li>\n                    <a href='https://www.javascript.com/'>\n                        JavaScript\n                    </a>\n                </li>\n                <li>\n                    <a href='https://gojs.net/latest/index.html'>\n                        GoJS\n                    </a>\n                </li>\n                <li>\n                    <a href='https://lodash.com/'>\n                        Lodash\n                    </a>\n                </li>\n                <li>\n                    <a href='https://jestjs.io/'>\n                        Jest\n                    </a>\n                </li>\n            </ul>\n\n        </div>\n    )\n}\n\nexport default Documentation;","import React from 'react';\nimport { BrowserRouter, Redirect, Route, Switch} from 'react-router-dom'\nimport Main from './components/Main';\nimport Header from './components/Header';\nimport MainNotDirected from './components/MainNotDirected';\nimport InitialPage from './components/InitialPage';\nimport Documentation from './components/Documentation';\n\nconst App = () => (\n  <BrowserRouter>\n    <Header />\n    <Switch>\n      <Route exact path='/' component={InitialPage} />\n      <Route exact path='/dirigido' component={Main} />\n      <Route exact path='/no-dirigido' component={MainNotDirected} />\n      <Route exact path='/documentacion' component={Documentation} />\n      <Redirect to='/' />\n    </Switch>\n    \n\n  </BrowserRouter>\n\n)\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './assets/styles/settings.scss'\nimport App from './App';\nimport \"core-js/stable\";\nimport \"regenerator-runtime/runtime\";\n\nReactDOM.render(\n  <>\n    <App />\n  </>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}