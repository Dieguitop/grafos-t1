{"version":3,"sources":["components/Content.js","lib/grafo/nodo.js","lib/grafo/arista.js","lib/conjunto-disjunto.js","lib/grafo/algoritmos.js","lib/grafo/grafo.js","components/RowLink.js","components/Row.js","components/Main.js","components/Header.js","components/NotDirected.js","components/MainNotDirected.js","components/InitialPage.js","assets/img/doc-ex.PNG","assets/img/link-ex.PNG","assets/img/graph.PNG","components/Documentation.js","App.js","index.js"],"names":["avoidNodeOverlap","node","pt","gridpt","isUnoccupied","r","navig","obj","part","go","isMemberOf","lit","diagram","layers","next","lay","value","isTemporary","findObjectsIn","count","bnds","actualBounds","loc","location","x","y","width","height","inflate","currentTool","_temp","layer","FDLayout","call","this","initDiagram","$","make","text","color","fig","initialAutoScale","Uniform","layout","model","linkKeyProperty","spacing","parseFloat","ConstantSpacing","nodeTemplate","name","fill","strokeWidth","portId","margin","editable","font","makeTwoWay","dragComputation","linkTemplate","curve","Bezier","toArrow","segmentOffset","inherit","prototype","makeNetwork","coll","net","vertexes","each","vertex","isFixed","isSelected","Content","data","linksData","className","divClassName","nodeDataArray","linkDataArray","Adyacente","nodo","peso","Boolean","Direccion","Object","freeze","salida","entrada","ambas","Arista","origen","destino","from","to","link","Number","undefined","ConjuntoDisjunto","padre","grado","rx","buscar","ry","permutar","lista","length","cabeza","resto","permutacion","keys","i","slice","izquierda","derecha","f","caminoDeAumento","grafo","capacidad","Array","cantidad","cola","flujo","Infinity","isEmpty","shift","actual","adyacentes","siguiente","capacidadArista","flujoCamino","Math","min","push","Celda","conectada","desconectada","Trayecto","camino","ciclo","Grafo","esDirigido","listaDeAdyacencia","Map","n","matrizDeAdyacencia","map","j","celda","listaDeAristas","sortedUniq","flattenDeep","sort","a","b","nodos","visitar","first","includes","values","some","adyacente","direccion","existeArista","find","agregarArista","get","has","indiceMenor","sortedIndexBy","splice","ultimo","last","set","remove","explicitos","entrantes","unionBy","trayecto","matrizDeCaminos","identity","ultimaPotencia","add","multiply","toArray","distancia","noVisitados","Set","reduce","menor","distanciaDesdeOrigen","delete","reverse","candidatosOrigen","candidatosDestino","tipo","impares","impar","hierholzer","euleriano","cloneDeep","subtrayecto","pop","eliminarArista","esEuleriano","calculado","hamiltoniano","esTrayecto","anterior","arbol","conjunto","crear","aristas","arista","raizOrigen","raizDestino","unir","sumBy","entries","fila","listaDeLinks","desdeLink","RowLink","onChange","onRemove","FormControl","m","Box","display","justifyContent","p","TextField","id","label","type","InputProps","inputProps","max","InputLabelProps","shrink","e","target","Button","size","startIcon","style","fontSize","onClick","Row","fullWidth","bugout","Debugout","Main","info","defaultState","useState","rows","setRows","links","setLinks","doneFetch","setDoneFetch","doneFetchDistance","setDoneFetchDistance","doneFetchHamEul","setDoneFetchHamEul","doneFetchFlujoMaximo","setDoneFetchFlujoMaximo","doneFetchArbol","setDoneFetchArbol","desde","hasta","changeData","setChangeData","changePeakData","setChangePeakData","edgesClass","setEdgesClass","setGrafo","arbolGenerador","setArbolGenerador","matrizDeCamino","setMatrizDeCamino","saveAllData","setSaveAllData","isHamiltoniano","setIsHamiltoniano","isEuleriano","setIsEuleriano","isConexo","setIsConexo","distance","setDistance","shortPath","setShortPath","distanceFrom","setDistanceFrom","distanceTo","setDistanceTo","peakFlowFrom","setPeakFlowFrom","peakFlowTo","setPeakFlowTo","peakFlow","setPeakFlow","validation","setValidation","eulerianPath","setEulerianPath","eulerianCycle","setEulerianCycle","hamiltonianPath","setHamiltonianPath","hamiltonianCycle","setHamiltonianCycle","grafoClass","numberFrom","numberTo","numberPeso","concat","handleArbol","handleFlujoMaximo","handleDistance","handleHamEul","handleMatriz","saveData","swal","gra","desdeListaDeAristas","esHamiltoniano","esConexo","agm","arbolGeneradorMinimo","caminoMasCorto","shortPathGraph","distanceShortes","peak","flujoMaximo","error","handleOnChangeLinks","index","copyLinks","edge","saveArista","handleInputChangeFromTo","preventDefault","peakFlowFromTo","getFromTo","handleInputPeakFlow","variant","len","row","copyRows","key","handleOnChange","warn","handleOnRemove","handleOnRemoveLink","disabled","SaveAlt","item","miniItem","onSubmit","window","reload","realTimeLoggingOn","downloadLog","Header","AppBar","position","Toolbar","NotDirected","MainNotDirected","InitialPage","Documentation","src","DocEx","alt","LinkEx","Graph","href","App","exact","path","component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9dc0db0a.chunk.js","sourcesContent":["import React from \"react\";\r\nimport * as go from \"gojs\";\r\nimport { ReactDiagram } from \"gojs-react\";\r\n\r\n// https://gojs.net/latest/samples/dragUnoccupied.html\r\nfunction avoidNodeOverlap(node, pt, gridpt) {\r\n  function isUnoccupied(r, node) {\r\n    let diagram = node.diagram;\r\n\r\n    function navig(obj) {\r\n      let part = obj.part;\r\n      if (part === node) return null;\r\n      if (part instanceof go.Link) return null;\r\n      if (part.isMemberOf(node)) return null;\r\n      if (node.isMemberOf(part)) return null;\r\n      return part;\r\n    }\r\n\r\n    let lit = diagram.layers;\r\n    while (lit.next()) {\r\n      let lay = lit.value;\r\n      if (lay.isTemporary) continue;\r\n      if (lay.findObjectsIn(r, navig, null, true).count > 0) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  if (node.diagram instanceof go.Palette) return gridpt;\r\n  let bnds = node.actualBounds;\r\n  let loc = node.location;\r\n  let r = new go.Rect(\r\n    gridpt.x - (loc.x - bnds.x),\r\n    gridpt.y - (loc.y - bnds.y),\r\n    bnds.width,\r\n    bnds.height\r\n  );\r\n\r\n  r.inflate(-0.5, -0.5);\r\n\r\n  if (\r\n    !(node.diagram.currentTool instanceof go.DraggingTool) &&\r\n    (!node._temp || !node.layer.isTemporary)\r\n  ) {\r\n    node._temp = true;\r\n    while (!isUnoccupied(r, node)) {\r\n      r.x += 10;\r\n      r.y += 2;\r\n    }\r\n    r.inflate(0.5, 0.5);\r\n    return new go.Point(r.x - (loc.x - bnds.x), r.y - (loc.y - bnds.y));\r\n  }\r\n  if (isUnoccupied(r, node)) return gridpt;\r\n  return loc;\r\n}\r\n\r\n// https://gojs.net/latest/samples/fdLayout.html\r\nfunction FDLayout() {\r\n  go.ForceDirectedLayout.call(this);\r\n}\r\n\r\ngo.Diagram.inherit(FDLayout, go.ForceDirectedLayout);\r\n\r\nFDLayout.prototype.makeNetwork = function (coll) {\r\n  let net = go.ForceDirectedLayout.prototype.makeNetwork.call(this, coll);\r\n\r\n  net.vertexes.each(function (vertex) {\r\n    let node = vertex.node;\r\n    if (node !== null) vertex.isFixed = node.isSelected;\r\n  });\r\n\r\n  return net;\r\n};\r\n\r\nfunction initDiagram() {\r\n  const $ = go.GraphObject.make;\r\n  \r\n  const diagram = $(go.Diagram, {\r\n    \"undoManager.isEnabled\": true,\r\n    \"clickCreatingTool.archetypeNodeData\": { text: \"new node\", color: \"lightblue\", fig: \"Cloud\" },\r\n    initialAutoScale: go.Diagram.Uniform, // Zoom to make everything fit in the viewport.\r\n    layout: $(go.CircularLayout),\r\n    model: $(go.GraphLinksModel, {\r\n      linkKeyProperty: \"key\",\r\n    }),\r\n  });\r\n\r\n  var lay = diagram.layout;\r\n\r\n  var spacing = 200;\r\n  spacing = parseFloat(spacing, 200);\r\n  lay.spacing = spacing;\r\n\r\n  lay = go.CircularLayout.ConstantSpacing;\r\n\r\n  diagram.nodeTemplate = $(\r\n    go.Node,\r\n    \"Auto\", // the Shape will go around the TextBlock\r\n    new go.Binding(),\r\n    $(\r\n      go.Shape,\r\n      \"Circle\",\r\n      { name: \"SHAPE\", fill: \"white\", strokeWidth: 1, portId: \"\", },\r\n      // Shape.fill is bound to Node.data.color\r\n      new go.Binding(\"fill\", \"color\")\r\n    ),\r\n    $(\r\n      go.TextBlock,\r\n      { margin: 10, editable: false, font: \"26px Verdana\" },\r\n      new go.Binding(\"text\").makeTwoWay()\r\n    ),\r\n    { dragComputation: avoidNodeOverlap }\r\n  );\r\n\r\n  diagram.linkTemplate = $(\r\n    go.Link,\r\n    { curve: go.Link.Bezier },\r\n    $(go.Shape),\r\n    $(go.Shape, { toArrow: \"Standard\" }),\r\n    $(\r\n      go.TextBlock,\r\n      { font: \"24px Verdana\", segmentOffset: new go.Point(0, -20) },\r\n      new go.Binding(\"text\", \"text\")\r\n    )\r\n  );\r\n\r\n  return diagram;\r\n}\r\n\r\nconst Content = ({ data, linksData }) => {\r\n  return (\r\n    <div className=\"content\">\r\n      <ReactDiagram\r\n        initDiagram={initDiagram}\r\n        divClassName=\"diagram-component\"\r\n        nodeDataArray={data}\r\n        linkDataArray={linksData}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Content;\r\n","/**\r\n * Representación de un nodo adyacente.\r\n * @class\r\n */\r\nclass Adyacente {\r\n  /*\r\n   * @constructor\r\n   * @param {number} nodo - Nodo adyacente.\r\n   * @param {number} peso - Peso de la arista.\r\n   */\r\n  constructor(nodo, peso) {\r\n    this.nodo = nodo;\r\n    this.peso = peso;\r\n  }\r\n\r\n  get esPonderado() {\r\n    return Boolean(this.peso);\r\n  }\r\n}\r\n\r\nexport { Adyacente };\r\n","import { Adyacente } from './nodo.js';\r\n\r\n/**\r\n * @enum {number}\r\n *\r\n * Representa la dirección de una arista.\r\n */\r\nconst Direccion = Object.freeze({\r\n  salida: 1,\r\n  entrada: 2,\r\n  ambas: 3,\r\n});\r\n\r\n/**\r\n * Representación de una arista.\r\n * @class\r\n */\r\nclass Arista {\r\n  /**\r\n   * @constructor\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number|Adyacente} destino - Nodo destino.\r\n   * @param {number} peso - Peso de la arista.\r\n   *\r\n   * Notar que si el nodo destino es de tipo `Adyacente`, el parámetro peso es\r\n   * ignorado.\r\n   */\r\n  constructor(origen, destino, peso) {\r\n    this.origen = origen;\r\n\r\n    if (destino instanceof Adyacente) {\r\n      this.destino = destino.nodo;\r\n      this.peso = destino.peso;\r\n    } else {\r\n      this.destino = destino;\r\n      this.peso = peso;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} Link\r\n   *   @property {string} from - Origen de la arista.\r\n   *   @property {string} to - Destino de la arista.\r\n   *   @property {string} text - Peso de la arista.\r\n   */\r\n  /**\r\n   * Construye una lista a partir de un link.\r\n   *\r\n   * @param {Link} link - Link.\r\n   */\r\n  static desdeLink(link) {\r\n    const { from, to, text } = link;\r\n    return new Arista(Number(from), Number(to), text == null ? undefined : Number(text));\r\n  }\r\n\r\n  /**\r\n   * Comprueba si la arista es ponderada.\r\n   *\r\n   * @returns {boolean} `true` si la arista es ponderada, `false` en caso\r\n   * contrario.\r\n   */\r\n  get esPonderada() {\r\n    return this.peso != null;\r\n  }\r\n\r\n  /**\r\n   * Convierte la arista a un link.\r\n   *\r\n   * @returns {Link} Link.\r\n   */\r\n  get link() {\r\n    return {\r\n      from: this.origen,\r\n      to: this.destino,\r\n      text: this.peso,\r\n    };\r\n  }\r\n}\r\n\r\nexport { Arista, Direccion };\r\n","/**\r\n * Representación de un conjunto disjunto.\r\n * @class\r\n */\r\nclass ConjuntoDisjunto {\r\n  /**\r\n   * @constructor\r\n   */\r\n  constructor() {\r\n    this.padre = [];\r\n    this.grado = [];\r\n  }\r\n\r\n  /**\r\n   * Crea un nuevo conjunto, donde el nodo x es el único nodo del conjunto.\r\n   *\r\n   * @param {any} x - Nodo a agregar.\r\n   * @returns {void}\r\n   */\r\n  crear(x) {\r\n    this.padre[x] = x;\r\n    this.grado[x] = 0;\r\n  }\r\n\r\n  /**\r\n   * Busca el nodo raíz que representa al conjunto que contiene al nodo x.\r\n   *\r\n   * @param {any} x - Nodo cuya raíz representativa es buscada.\r\n   * @returns {any} Raíz que representa al conjunto que contiene al nodo x.\r\n   *\r\n   * Implementación del algoritmo de división de camino, de una pasada.\r\n   */\r\n  buscar(x) {\r\n    while (x !== this.padre[x]) {\r\n      // Reemplaza cada nodo por su padre, y cada padre por su respectivo padre.\r\n      [x, this.padre[x]] = [this.padre[x], this.padre[this.padre[x]]];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n  /**\r\n   * Une los conjuntos de los elementos x e y en un sólo conjunto.\r\n   *\r\n   * @param {any} x - Nodo cuyo conjunto se une con el conjunto del nodo y.\r\n   * @param {any} y - Nodo cuyo conjunto se une con el conjunto del nodo x.\r\n   * @returns {boolean} `true` si los conjuntos fueron unidos, `false` en caso contrario.\r\n   *\r\n   * Implementación del algoritmo de unión por grado (rank).\r\n   */\r\n  unir(x, y) {\r\n    // Raíz del nodo x.\r\n    let rx = this.buscar(x);\r\n\r\n    // Raíz del nodo y.\r\n    let ry = this.buscar(y);\r\n\r\n    if (rx === ry) {\r\n      // Los elementos ya están en el mismo conjunto.\r\n      return false;\r\n    }\r\n\r\n    // Si es necesario, reasignar las variables para garantizar que el grado de x es\r\n    // mayor o igual que el grado de y.\r\n    if (this.grado[rx] < this.grado[ry]) {\r\n      [rx, ry] = [ry, rx];\r\n    }\r\n\r\n    // Establecer a la raíz de x como la nueva raíz de y.\r\n    this.padre[ry] = rx;\r\n\r\n    // Si el grado de la raíz de x es igual al grado de la raíz de y, aumenta el grado de x\r\n    // (aumenta el límite superior de la altura del nodo x).\r\n    if (this.grado[rx] === this.grado[ry]) {\r\n      this.grado[rx] += 1;\r\n    }\r\n\r\n    // Los conjuntos del nodo x e y fueron unidos.\r\n    return true;\r\n  }\r\n}\r\n\r\nexport { ConjuntoDisjunto };\r\n","import { isEmpty } from \"lodash-es\";\r\nimport { Direccion } from \"./arista.js\";\r\n\r\n/**\r\n * Produce una permutación de una lista de números.\r\n *\r\n * @param {number[]} lista - Lista a calcular permutaciones.\r\n * @yields {number[]} La siguiente permutación de la lista de números.\r\n */\r\nexport function* permutar(lista) {\r\n  // Caso base.\r\n  if (lista.length === 1) {\r\n    yield lista;\r\n  } else {\r\n    // Obtiene el primer elemento de la lista, y el resto de la lista.\r\n    let [cabeza, ...resto] = lista;\r\n\r\n    // Generación recursiva de permutaciones, una por cada iteración.\r\n    for (const permutacion of permutar(resto)) {\r\n      for (const i of lista.keys()) {\r\n        // Divide en 2 la permutación, en el índice j.\r\n        const [izquierda, derecha] = [permutacion.slice(0, i), permutacion.slice(i)];\r\n\r\n        // Produce la siguiente permutación.\r\n        yield [...izquierda, cabeza, ...derecha];\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @typedef {Object} CaminoDeAumento\r\n *   @property {number} flujoCamino - Capacidad residual mínima del camino\r\n *   de aumento.\r\n *   @property {number[]} padre - Lista de padres de cada nodo, siguiendo el\r\n *   camino de aumento.\r\n */\r\n/**\r\n * Recorre el grafo para encontrar un camino de aumento (CA).\r\n *\r\n * @param {number} entrada - Nodo donde comienza el camino de aumento.\r\n * @param {number} salida - Nodo donde termina el camino de aumento.\r\n * @param {number[][]} capacidad - Matriz de capacidades residuales de las\r\n * aristas del grafo.\r\n * @returns {CaminoDeAumento} Flujo del camino de aumento, y lista de padres\r\n * de cada nodo, siguiendo el mismo camino de aumento.\r\n *\r\n * Algoritmo de búsqueda en anchura (breadth-first search, BFS).\r\n */\r\nexport function caminoDeAumento(grafo, entrada, salida, capacidad) {\r\n  // Arreglo utilizado para recordar los nodos padres de cada nodo i-ésimo\r\n  // (si es que fue visitado).\r\n  let padre = Array(grafo.cantidad);\r\n\r\n  // El nodo entrada no tiene padre.\r\n  padre[entrada] = null;\r\n\r\n  // Se utiliza una cola para almacenar los nodos que están en el mismo\r\n  // nivel del nodo actual (nodo entrada, inicialmente), más el flujo del\r\n  // CA asociado al nodo ingresado.\r\n  for (let cola = [{ nodo: entrada, flujo: Infinity }]; !isEmpty(cola); ) {\r\n    // Extrae el primer elemento de la cola.\r\n    const { nodo: actual, flujo } = cola.shift();\r\n\r\n    // Se exploran los adyacentes (de salida y de entrada) del nodo actual.\r\n    for (const { nodo: siguiente } of grafo.adyacentes(actual, Direccion.ambas)) {\r\n      // Capacidad residual de la arista {actual, siguiente}.\r\n      const capacidadArista = capacidad[actual][siguiente];\r\n\r\n      // Comprueba si el nodo siguiente no ha sido visitado (porque su padre\r\n      // no está definido) y si la capacidad residual de la arista {actual,\r\n      // siguiente} es positiva.\r\n      if (padre[siguiente] === undefined && capacidadArista > 0) {\r\n        // Recordar el nodo padre (nodo actual) del nodo siguiente.\r\n        padre[siguiente] = actual;\r\n\r\n        // Calcula la capacidad residual menor del CA.\r\n        let flujoCamino = Math.min(flujo, capacidadArista);\r\n\r\n        // Comprueba si se ha llegado al final del CA.\r\n        if (siguiente === salida) {\r\n          return { flujoCamino, padre };\r\n        }\r\n\r\n        // Ingresa a la cola el nodo siguiente (un nivel más abajo del nodo\r\n        // de entrada).\r\n        cola.push({ nodo: siguiente, flujo: flujoCamino });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Si el flujo del camino es 0, entonces no se encontró ningún CA.\r\n  return { flujoCamino: 0, padre };\r\n}\r\n","import { Arista, Direccion } from \"./arista.js\";\r\nimport { Adyacente } from \"./nodo.js\";\r\nimport { ConjuntoDisjunto } from \"../conjunto-disjunto.js\";\r\nimport { permutar, caminoDeAumento } from \"./algoritmos.js\";\r\nimport { identity, add, multiply } from \"mathjs/lib/esm/index.js\";\r\nimport {\r\n  cloneDeep,\r\n  find,\r\n  first,\r\n  flattenDeep,\r\n  isEmpty,\r\n  last,\r\n  remove,\r\n  some,\r\n  sumBy,\r\n  unionBy,\r\n  sortedIndexBy,\r\n  sortedUniq,\r\n} from \"lodash-es\";\r\n\r\n/**\r\n * @enum {boolean}\r\n *\r\n * Representa la conexión entre dos nodos i y j en la celda {i, j} de la matriz\r\n * de adyacencia.\r\n */\r\nconst Celda = Object.freeze({\r\n  conectada: true,\r\n  desconectada: false,\r\n});\r\n\r\n/**\r\n * @enum {number}\r\n *\r\n * Representa los tipos de trayecto en un grafo.\r\n */\r\nconst Trayecto = Object.freeze({\r\n  camino: 1,\r\n  ciclo: 2,\r\n});\r\n\r\n/**\r\n * Representación de un grafo.\r\n * @class\r\n */\r\nclass Grafo {\r\n  /**\r\n   * @constructor\r\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\r\n   * adyacencia es dirigido, `false` en caso contrario.\r\n   */\r\n  constructor(esDirigido = false) {\r\n    this.listaDeAdyacencia = new Map();\r\n    this.esDirigido = esDirigido;\r\n  }\r\n\r\n  /**\r\n   * Construye un grafo a partir de una lista de adyacencia.\r\n   *\r\n   * @param {Map<number, number[]>} listaDeAdyacencia - Lista de adyacencia.\r\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\r\n   * adyacencia es dirigido, `false` en caso contrario.\r\n   * @returns {Grafo} Grafo.\r\n   *\r\n   * La implementación interna de `Grafo` es una lista de adyacencia, por lo que\r\n   * éste constructor redirige al constructor principal.\r\n   *\r\n   * @example\r\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\r\n   * const listaDeAdyacencia = [\r\n   *   [0, [new Adyacente(1, 2), new Adyacente(2, 6)]],\r\n   *   [1, [new Adyacente(2, 3)]],\r\n   *   [2, [new Adyacente(0, 4)]]\r\n   * ];\r\n   *\r\n   * // La lista de adyacencia contiene aristas dirigidas.\r\n   * const esDirigido = true;\r\n   * const grafo = Grafo.desdeListaDeAdyacencia(matrizDeAdyacencia, esDirigido);\r\n   */\r\n  static desdeListaDeAdyacencia(listaDeAdyacencia, esDirigido = false) {\r\n    let grafo = new Grafo(esDirigido);\r\n\r\n    for (const [i, adyacentes] of listaDeAdyacencia) {\r\n      for (const { nodo: j, peso } of adyacentes) {\r\n        grafo.agregarArista(i, j, peso, Direccion.salida);\r\n      }\r\n    }\r\n\r\n    return grafo;\r\n  }\r\n\r\n  /**\r\n   * Construye un grafo a partir de una matriz de adyacencia.\r\n   *\r\n   * @param {number[][]} matrizDeAdyacencia - Matriz de adyacencia.\r\n   * @param {boolean} esDirigido - `true` si el grafo de la matriz de adyacencia\r\n   * es dirigido, `false` en caso contrario.\r\n   * @returns {Grafo} Grafo.\r\n   *\r\n   * @example\r\n   * // Grafo: 0 -> 1, 0 <-> 2, 1 -> 2.\r\n   * const matrizDeAdyacencia = [\r\n   *   [false, true, true],\r\n   *   [false, false, true],\r\n   *   [true, false, false]\r\n   * ];\r\n   *\r\n   * // La matriz contiene aristas dirigidas.\r\n   * const esDirigido = true;\r\n   * const grafo = Grafo.desdeMatrizDeAdyacencia(\r\n   *   matrizDeAdyacencia, esDirigido\r\n   * );\r\n   */\r\n  static desdeMatrizDeAdyacencia(matrizDeAdyacencia, esDirigido = false) {\r\n    let grafo = new Grafo(esDirigido);\r\n\r\n    for (const [i, fila] of matrizDeAdyacencia.entries()) {\r\n      for (const [j, celda] of fila.entries()) {\r\n        if (celda !== Celda.desconectada) {\r\n          grafo.agregarArista(\r\n            i,\r\n            j,\r\n            celda === Celda.conectada ? undefined : celda,\r\n            Direccion.salida\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    return grafo;\r\n  }\r\n\r\n  /**\r\n   * Construye un grafo a partir de una lista de aristas.\r\n   *\r\n   * @param {number[][]} listaDeAristas - Lista de aristas.\r\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la matriz de\r\n   * adyacencia es dirigido, `false` en caso contrario.\r\n   * @returns {Grafo} Grafo.\r\n   *\r\n   * @example\r\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\r\n   * const listaDeAristas = [\r\n   *   new Arista(0, 1, 2),\r\n   *   new Arista(0, 2, 6),\r\n   *   new Arista(1, 2, 3),\r\n   *   new Arista(2, 0, 4)\r\n   * ];\r\n   *\r\n   * // La lista contiene aristas dirigidas.\r\n   * const esDirigido = true;\r\n   * const grafo = Grafo.desdeListaDeAristas(listaDeAristas, esDirigido);\r\n   */\r\n  static desdeListaDeAristas(listaDeAristas, esDirigido = false) {\r\n    let grafo = new Grafo(esDirigido);\r\n\r\n    for (const { origen, destino, peso } of listaDeAristas) {\r\n      grafo.agregarArista(origen, destino, peso, Direccion.salida);\r\n    }\r\n\r\n    return grafo;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} Link\r\n   *   @property {string} from - Origen de la arista.\r\n   *   @property {string} to - Destino de la arista.\r\n   *   @property {string} text - Peso de la arista.\r\n   */\r\n  /**\r\n   * Construye un grafo a partir de una lista de links.\r\n   *\r\n   * @param {Link[]} listaDeLinks - Lista de links.\r\n   * @param {boolean} [esDirigido=false] - `true` si el grafo de la lista de\r\n   * links es dirigido, `false` en caso contrario.\r\n   *\r\n   * @example\r\n   * // Grafo: 0 --(1)--> 1, 0 --(4)--> 2, 0 --(7)--> 3, 1 --(9)--> 2.\r\n   * const listaDeLinks = [\r\n   *   { from: \"0\", to: \"1\", text: \"1\" },\r\n   *   { from: \"0\", to: \"2\", text: \"4\" },\r\n   *   { from: \"0\", to: \"3\", text: \"7\" },\r\n   *   { from: \"1\", to: \"2\", text: \"9\" },\r\n   * ];\r\n   *\r\n   * // La lista de links no contiene aristas dirigidas.\r\n   * const esDirigido = false;\r\n   * const grafo = Grafo.desdeListaDeLinks(listaDeLinks, esDirigido);\r\n   */\r\n  static desdeListaDeLinks(listaDeLinks, esDirigido = false) {\r\n    let grafo = new Grafo(esDirigido);\r\n\r\n    for (const link of listaDeLinks) {\r\n      const { origen, destino, peso } = Arista.desdeLink(link);\r\n      grafo.agregarArista(origen, destino, peso, Direccion.salida);\r\n    }\r\n\r\n    return grafo;\r\n  }\r\n\r\n  /**\r\n   * Obtiene la matriz de adyacencia asociada al grafo.\r\n   *\r\n   * @returns {number[][]} Matriz de adyacencia.\r\n   */\r\n  get matrizDeAdyacencia() {\r\n    const n = this.cantidad;\r\n\r\n    // Crea una matriz de orden n, cuyos valores son inicialmente `false`.\r\n    let matrizDeAdyacencia = Array(n)\r\n      .fill()\r\n      .map(() => Array(n).fill(Celda.desconectada));\r\n\r\n    for (const [i, adyacentes] of this.listaDeAdyacencia) {\r\n      for (const { nodo: j, peso: celda } of adyacentes) {\r\n        // Si el adyacente es ponderado, el valor de la celda {i, j} corresponde\r\n        // al peso de la arista que une al nodo i con el nodo j. En caso\r\n        // contrario, a la celda {i, j} se la asigna `true`.\r\n        matrizDeAdyacencia[i][j] = celda ?? Celda.conectada;\r\n\r\n        // La matriz de adyacencia de un grafo no dirigido es simétrica, por\r\n        // lo que la arista entre el nodo i y el nodo j existe en dicha matriz\r\n        // tanto en {i, j} y como en {j, i}.\r\n        if (!this.esDirigido) {\r\n          matrizDeAdyacencia[j][i] = celda ?? Celda.conectada;\r\n        }\r\n      }\r\n    }\r\n\r\n    return matrizDeAdyacencia;\r\n  }\r\n\r\n  /**\r\n   * Obtiene la lista de aristas asociada al grafo.\r\n   *\r\n   * @returns {number[][]} Lista de aristas.\r\n   */\r\n  get listaDeAristas() {\r\n    let listaDeAristas = [];\r\n\r\n    for (const [origen, adyacentes] of this.listaDeAdyacencia) {\r\n      for (const { nodo: destino, peso } of adyacentes) {\r\n        listaDeAristas.push(new Arista(origen, destino, peso));\r\n      }\r\n    }\r\n\r\n    return listaDeAristas;\r\n  }\r\n\r\n  /**\r\n   * Obtiene la lista con todos los nodos del grafo.\r\n   *\r\n   * @returns {number[]} Lista de nodos.\r\n   */\r\n  get nodos() {\r\n    // Descomprime el arreglo interno de la lista de adyacencia en un arreglo de\r\n    // una dimensión, se omite el peso de los adyacentes ponderados, se ordenan\r\n    // los nodos ascendentemente y se filtran los duplicados.\r\n    return sortedUniq(\r\n      flattenDeep([...this.listaDeAdyacencia])\r\n        .map((nodo) => nodo?.nodo ?? nodo)\r\n        .sort((a, b) => a - b)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Calcula la cantidad de nodos del grafo.\r\n   *\r\n   * @returns {number} Cantidad de nodos.\r\n   */\r\n  get cantidad() {\r\n    return this.nodos.length;\r\n  }\r\n\r\n  /**\r\n   * Comprueba si el grafo es conexo.\r\n   *\r\n   * @returns {boolean} `true` si el grafo es conexo, `false` en caso contrario.\r\n   */\r\n  get esConexo() {\r\n    /**\r\n     * Recorre el grafo.\r\n     *\r\n     * @param {number} origen - Nodo donde comienza el recorrido.\r\n     * @returns {number[]} Nodos padre de cada nodo i-ésimo (si fue visitado).\r\n     *\r\n     * Algoritmo de búsqueda en anchura (breadth-first search, BFS).\r\n     */\r\n    const visitar = (origen) => {\r\n      // Arreglo utilizado para recordar los nodos padres de cada nodo i-ésimo\r\n      // (si es que fue visitado).\r\n      let padre = Array(this.cantidad);\r\n\r\n      // El nodo origen no tiene padre.\r\n      padre[origen] = null;\r\n\r\n      // Se utiliza una cola para almacenar los nodos que están en el mismo\r\n      // nivel del nodo actual (nodo origen, inicialmente).\r\n      for (let cola = [origen]; !isEmpty(cola); ) {\r\n        // Extrae el primer elemento de la cola.\r\n        const actual = cola.shift();\r\n\r\n        // Se exploran los adyacentes del nodo actual.\r\n        for (const { nodo: siguiente } of this.adyacentes(actual)) {\r\n          // Comprueba si el nodo siguiente no ha sido visitado (porque su padre\r\n          // no está definido).\r\n          if (padre[siguiente] === undefined) {\r\n            // Recordar el nodo padre (nodo actual) del nodo siguiente.\r\n            padre[siguiente] = actual;\r\n\r\n            // Ingresa a la cola el nodo siguiente (un nivel más abajo del nodo\r\n            // origen).\r\n            cola.push(siguiente);\r\n          }\r\n        }\r\n      }\r\n\r\n      return padre;\r\n    };\r\n\r\n    // Si al recorrer el grafo, uno de los nodos no fue visitado, entonces el\r\n    // grafo no es conexo.\r\n    return !visitar(first(this.nodos)).includes(undefined);\r\n  }\r\n\r\n  /**\r\n   * Comprueba si el grafo es ponderado.\r\n   *\r\n   * @returns {boolean} `true` si el grafo es ponderado, `false` en caso\r\n   * contrario.\r\n   */\r\n  get esPonderado() {\r\n    // Comprueba si alguno de los adyacentes de la lista de adyacencia es\r\n    // ponderado.\r\n    return [...this.listaDeAdyacencia.values()].some((adyacente) => some(adyacente, \"esPonderado\"));\r\n  }\r\n\r\n  /**\r\n   * Comprueba si existe una arista entre el nodo origen y el nodo destino.\r\n   *\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number} destino - Nodo destino.\r\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\r\n   * buscada.\r\n   * @returns {boolean} `true` si la arista entre el nodo origen y el nodo\r\n   * destino existe, `false` en caso contrario.\r\n   *\r\n   * @todo Aristas no dirigidas vs doble aristas de salida y de entrada\r\n   * (multigrafo). Ver también método `arista`.\r\n   */\r\n  existeArista(origen, destino, direccion = Direccion.salida) {\r\n    return some(this.adyacentes(origen, direccion), [\"nodo\", destino]);\r\n  }\r\n\r\n  /**\r\n   * Comprueba si existe una arista entre el nodo origen y el nodo destino.\r\n   *\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number} destino - Nodo destino.\r\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\r\n   * buscada.\r\n   * @returns {Arista|boolean} Arista, si existe; `false`, en caso contrario.\r\n   *\r\n   * @todo Aristas no dirigidas vs doble aristas de salida y de entrada\r\n   * (multigrafo). Ver también método `existeArista`.\r\n   */\r\n  arista(origen, destino, direccion = Direccion.salida) {\r\n    if (!this.existeArista(origen, destino, direccion)) {\r\n      return false;\r\n    }\r\n\r\n    // Encuentra el nodo destino en los adyacentes de entrada (si la arista\r\n    // encontrada es sólo de entrada) o en los adyacentes de salida (si la\r\n    // arista encontrada es sólo de salida, o de salida y además de entrada).\r\n    const { peso } = find(this.adyacentes(origen, direccion), [\"nodo\", destino]);\r\n\r\n    // Si se desea obtener una arista de entrada (es decir, dirigida desde el\r\n    // destino hacia el origen), se debe intercambiar el destino con el origen.\r\n    if (direccion === Direccion.entrada) {\r\n      return new Arista(destino, origen, peso);\r\n    }\r\n\r\n    return new Arista(origen, destino, peso);\r\n  }\r\n\r\n  /**\r\n   * Crea una arista entre dos nodos de un grafo.\r\n   *\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number} destino - Nodo destino.\r\n   * @param {number} peso - Peso de la arista que une los nodos.\r\n   * @param {Direccion} direccion - Dirección de la arista entre los nodos.\r\n   * @returns {boolean} `true` si los nodos fueron conectados, `false` en caso\r\n   * contrario (los nodos ya estaban conectados).\r\n   */\r\n  agregarArista(origen, destino, peso, direccion = Direccion.salida) {\r\n    // Si la arista ya existe, no hay nada que insertar.\r\n    if (this.existeArista(origen, destino, direccion)) {\r\n      return false;\r\n    }\r\n\r\n    // Si el grafo es dirigido y la arista es de entrada, invertir los extremos.\r\n    else if (this.esDirigido && direccion === Direccion.entrada) {\r\n      return this.agregarArista(destino, origen, peso, Direccion.salida);\r\n    }\r\n\r\n    // Garantizar que el nodo origen es siempre menor al nodo destino.\r\n    else if (!this.esDirigido && origen > destino) {\r\n      [origen, destino] = [destino, origen];\r\n    }\r\n\r\n    let adyacentes = this.listaDeAdyacencia.get(origen);\r\n    const adyacente = new Adyacente(destino, peso);\r\n\r\n    if (this.listaDeAdyacencia.has(origen)) {\r\n      // Determina el índice mínimo en el que el adyacente debe ser insertado\r\n      // para mantener la lista de adyacentes ordenada.\r\n      const indiceMenor = sortedIndexBy(adyacentes, adyacente, \"nodo\");\r\n      adyacentes.splice(indiceMenor, 0, adyacente);\r\n    } else {\r\n      const ultimo = last([...this.listaDeAdyacencia.keys()]);\r\n      this.listaDeAdyacencia.set(origen, [adyacente]);\r\n\r\n      // Si existe un nodo mayor al nodo origen, ordenar la lista de adyacencia.\r\n      if (origen < ultimo) {\r\n        this.listaDeAdyacencia = new Map(\r\n          [...this.listaDeAdyacencia].sort((a, b) => first(a) - first(b))\r\n        );\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Elimina la arista, si existe, entre el nodo origen y el nodo destino.\r\n   *\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number} destino - Nodo destino.\r\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de la arista\r\n   * buscada.\r\n   * @returns {Adyacente[]|boolean} Si la arista existía, adyacentes explícitos\r\n   * del nodo origen; `false`, en caso contrario.\r\n   */\r\n  eliminarArista(origen, destino, direccion = Direccion.salida) {\r\n    if (!this.existeArista(origen, destino, direccion)) {\r\n      return false;\r\n    }\r\n\r\n    // Si la arista es dirigida hacia el origen, invertir los vértices.\r\n    // Para los grafos no dirigidos, basta con eliminar la arista de salida.\r\n    else if (this.esDirigido && direccion === Direccion.entrada) {\r\n      return remove(this.listaDeAdyacencia.get(destino), [\"nodo\", origen]);\r\n    }\r\n\r\n    // Si el grafo no es dirigido, asegurarse que el origen sea siempre menor\r\n    // que el destino.\r\n    else if (!this.esDirigido && origen > destino) {\r\n      [origen, destino] = [destino, origen];\r\n    }\r\n\r\n    return remove(this.listaDeAdyacencia.get(origen), [\"nodo\", destino]);\r\n  }\r\n\r\n  /**\r\n   * Obtiene los nodos adyacentes (de salida o entrada) a un nodo.\r\n   *\r\n   * @param {number} nodo - Nodo.\r\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de los nodos\r\n   * adyacentes al nodo.\r\n   * @returns {!Adyacente[]} Adyacentes al nodo.\r\n   *\r\n   * @example\r\n   * // Grafo: 0 --(2)--> 1, 0 <--(4)--.--(6)--> 2, 1 --(3)--> 2.\r\n   * const listaDeAdyacencia = [\r\n   *   [0, [new Adyacente(1, 2), new Adyacente(2, 6)]],\r\n   *   [1, [new Adyacente(2, 3)]],\r\n   *   [2, [new Adyacente(0, 4)]]\r\n   * ];\r\n   *\r\n   * // La lista de adyacencia contiene aristas dirigidas.\r\n   * const esDirigido = true;\r\n   * const grafo = new Grafo(listaDeAdyacencia, esDirigido);\r\n   *\r\n   * console.log(grafo.adyacentes(0, Direccion.entrada));\r\n   * // Valor esperado:\r\n   * // [new Adyacente(2, 4)]\r\n   */\r\n  adyacentes(nodo, direccion = Direccion.salida) {\r\n    /**\r\n     * Obtiene los nodos adyacentes que interna y explícitamente están\r\n     * asociados al nodo origen.\r\n     *\r\n     * @param {number} nodo - Nodo origen.\r\n     * @returns {!Adyacente[]} Lista de adyacentes de salida.\r\n     *\r\n     * Debido al funcionamiento de las listas de adyacencia, un nodo de un\r\n     * grafo no dirigido tiene nodos adyacentes que no están explícitamente\r\n     * asociados en dicha lista de adyacencia.\r\n     */\r\n    const explicitos = (nodo) => {\r\n      return this.listaDeAdyacencia.get(nodo) ?? [];\r\n    };\r\n\r\n    /**\r\n     * Obtiene los nodos adyacentes de salida del nodo.\r\n     *\r\n     * @param {number} nodo - Nodo origen.\r\n     * @returns {!Adyacente[]} Lista de adyacentes de salida.\r\n     *\r\n     * Los nodos adyacentes de entrada son aquellos que entregan alguna\r\n     * conexión al nodo origen.\r\n     */\r\n    const entrantes = (nodo) => {\r\n      let entrantes = [];\r\n\r\n      for (const [origen, adyacentes] of this.listaDeAdyacencia) {\r\n        let destino = find(adyacentes, [\"nodo\", nodo]);\r\n        if (destino != null) {\r\n          entrantes.push(new Adyacente(origen, destino.peso));\r\n        }\r\n      }\r\n\r\n      return entrantes;\r\n    };\r\n\r\n    // En los grafos no dirigidos las aristas no tienen dirección, pero como\r\n    // algunos adyacentes no están explícitos en la lista de adyacencia,\r\n    // se deben agregar los adyacentes implícitos (o de entrada, en caso de un\r\n    // grafo dirigido).\r\n    if (!this.esDirigido || direccion === Direccion.ambas) {\r\n      return unionBy(explicitos(nodo), entrantes(nodo), \"nodo\");\r\n    } else if (direccion === Direccion.salida) {\r\n      return explicitos(nodo);\r\n    } else if (direccion === Direccion.entrada) {\r\n      return entrantes(nodo);\r\n    }\r\n\r\n    // El nodo no tiene adyacentes.\r\n    return [];\r\n  }\r\n\r\n  /**\r\n   * Calcula el grado de un nodo.\r\n   *\r\n   * @param {number} nodo - Nodo.\r\n   * @param {Direccion} [direccion=Direccion.salida] - Dirección de los nodos\r\n   * adyacentes considerados en el grado.\r\n   * @returns {number} Grado del nodo.\r\n   *\r\n   * @todo Considerar caso de aristas bucle.\r\n   */\r\n  grado(nodo, direccion = Direccion.salida) {\r\n    // Si el grafo es dirigido, y se espera el grado total de un nodo, retornar\r\n    // la suma del grado de salida más el grado de entrada del nodo. En los\r\n    // grafos no dirigidos no hay distinción de dirección.\r\n    if (this.esDirigido && direccion === Direccion.ambas) {\r\n      return this.grado(nodo, Direccion.salida) + this.grado(nodo, Direccion.entrada);\r\n    }\r\n\r\n    // Se obtienen los adyacentes con la dirección específicada y se retorna la\r\n    // cantidad de ellos. Si el grafo no es dirigido, y no se provee una\r\n    // dirección específica, se retorna el grado de salida como grado total (no\r\n    // hay distinción de dirección en los grafos no dirigidos).\r\n    return this.adyacentes(nodo, direccion).length;\r\n  }\r\n\r\n  /**\r\n   * Comprueba si un trayecto es válido en el grafo.\r\n   *\r\n   * @param {number[]} trayecto - Trayecto.\r\n   * @returns {boolean} `true` si el  trayecto es válido en el grafo, `false` en\r\n   * caso contrario.\r\n   */\r\n  esTrayecto(trayecto) {\r\n    for (let i = 0; i < trayecto.length - 1; i++) {\r\n      // Comprueba que exista una arista (de salida) entre cada par de nodos\r\n      // {i, i + 1}.\r\n      if (!this.existeArista(trayecto[i], trayecto[i + 1])) {\r\n        // El trayecto no es válido dentro del grafo.\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // El trayecto es válido dentro del grafo.\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Obtiene la matriz de caminos asociada al grafo.\r\n   *\r\n   * @returns {number[][]} Matriz de caminos.\r\n   *\r\n   * El cálculo de la matriz de caminos está definido como la sumatoria de\r\n   * `A^i`, desde `i = 0`, hasta `i = n - 1`, donde `A` es la matriz de\r\n   * adyacencia del grafo, y n es la cantidad de nodos del mismo grafo. Desde `i\r\n   * = 2`, el resultado de `A^(i - 1)` se recuerda, para calcular el próximo\r\n   * término `A^i` como `A^(i - 1) * A`.\r\n   */\r\n  get matrizDeCaminos() {\r\n    const matrizDeAdyacencia = this.matrizDeAdyacencia;\r\n    const n = this.cantidad;\r\n\r\n    // A^0 es la matriz de identidad de orden n.\r\n    let matrizDeCaminos = identity(n);\r\n\r\n    // Como la iteración comienza en i = 2, se recuerda el valor de A^(i - 1),\r\n    // es decir, la matriz de adyacencia.\r\n    let ultimaPotencia = matrizDeAdyacencia;\r\n\r\n    for (let i = 2; i <= n; i++) {\r\n      matrizDeCaminos = add(matrizDeCaminos, ultimaPotencia);\r\n\r\n      // Calcular A^i como A^(i - 1) * A.\r\n      ultimaPotencia = multiply(ultimaPotencia, matrizDeAdyacencia);\r\n    }\r\n\r\n    return matrizDeCaminos.toArray();\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} CaminoMasCorto\r\n   *   @property {boolean|number[]} camino - Camino más corto entre el nodo\r\n   *   origen y el nodo destino, si existe; `false`, en caso contrario.\r\n   *   @property {number} distancia - Distancia total del camino más corto.\r\n   */\r\n  /** Obtiene el camino más corto entre dos nodos.\r\n   *\r\n   * @param {number} origen - Nodo origen.\r\n   * @param {number} destino - Nodo destino.\r\n   * @returns {CaminoMasCorto} Camino más corto y distancia total.\r\n   *\r\n   * Implementación del algoritmo de caminos mínimos de Dijkstra.\r\n   *\r\n   * @namespace caminoMasCorto\r\n   */\r\n  caminoMasCorto(origen, destino) {\r\n    const n = this.cantidad;\r\n\r\n    // Se recuerdan los nodos padres de cada nodo i-ésimo visitado, siguiendo la\r\n    // ruta óptima.\r\n    let padre = Array(n);\r\n\r\n    // Distancias (inicialmente infinitas) desde el nodo origen a cada nodo\r\n    // i-ésimo del grafo.\r\n    let distancia = Array(n).fill(Infinity);\r\n\r\n    // La distancia del nodo origen a sí mismo es 0.\r\n    distancia[origen] = 0;\r\n\r\n    for (let noVisitados = new Set(this.nodos); !isEmpty(noVisitados); ) {\r\n      // Se obtiene el nodo no visitado más cercano al nodo origen.\r\n      const actual = [...noVisitados].reduce((menor, nodo) =>\r\n        distancia[nodo] < distancia[menor] ? nodo : menor\r\n      );\r\n\r\n      // Si el nodo actual es el nodo destino, no es necesario seguir explorando\r\n      // sus adyacentes.\r\n      if (actual === destino) {\r\n        break;\r\n      }\r\n\r\n      // Se itera sobre todos los nodos adyacentes al nodo actual. Si el nodo no\r\n      // es ponderado, asignarle peso 1.\r\n      for (const { nodo: siguiente, peso } of this.adyacentes(actual)) {\r\n        // Calcula la distancia total desde el nodo origen hasta el actual.\r\n        const distanciaDesdeOrigen = distancia[actual] + (peso ?? 1);\r\n\r\n        // Si ésta distancia es menor a la registrada actualmente, se actualizan\r\n        // las distancias y los padres.\r\n        if (distanciaDesdeOrigen < distancia[siguiente]) {\r\n          distancia[siguiente] = distanciaDesdeOrigen;\r\n          padre[siguiente] = actual;\r\n        }\r\n      }\r\n\r\n      noVisitados.delete(actual);\r\n    }\r\n\r\n    // Si la distancia del nodo origen al nodo destino es infinita, entonces\r\n    // no existe un camino que los una.\r\n    if (distancia[destino] === Infinity) {\r\n      return { camino: false, distancia: 0 };\r\n    }\r\n\r\n    // Se calcula el camino más corto a partir de los nodos padres.\r\n    let camino = new Set([destino]);\r\n\r\n    // Se itera inversamente los nodos padres (del nodo destino al nodo origen).\r\n    for (let nodo = padre[destino]; nodo != null; nodo = padre[nodo]) {\r\n      camino.add(nodo);\r\n    }\r\n\r\n    // HACK: hay casos en que el origen ya viene incluido en el camino.\r\n    // Retorna el camino más corto (incluyendo el nodo origen) y la distancia\r\n    // total de la ruta.\r\n    return {\r\n      camino: [...camino.add(origen)].reverse(),\r\n      distancia: distancia[destino],\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} InfoTrayecto\r\n   *   @property {Trayecto} tipo - Tipo de trayecto (camino, ciclo, o ninguno).\r\n   *   @property {?number} origen - Nodo que origina el trayecto.\r\n   */\r\n  /**\r\n   * Determina si el grafo contiene un trayecto euleriano.\r\n   *\r\n   * @returns {InfoTrayecto|boolean} Tipo de trayecto (camino o ciclo) y nodo\r\n   * que origina el trayecto, si existe; `false`, en caso contrario.\r\n   *\r\n   * Condiciones que el grafo debe cumplir para que contenga un trayecto\r\n   * euleriano, donde GE es el grado de entrada de un nodo, y GS el grado de\r\n   * salida:\r\n   *            ┌─────────────────────────┬───────────────────────────────────┐\r\n   *            │     Ciclo euleriano     │          Camino euleriano         │\r\n   * ┌──────────┼─────────────────────────┼───────────────────────────────────┤\r\n   * │ No       │ Todos los nodos tienen  │ Todos los nodos tienen grado par, │\r\n   * │ dirigido │ grado par.              │ o exactamente 2 nodos tienen      │\r\n   * │          │                         │ grado impar. (1)                  │\r\n   * ├──────────┼─────────────────────────┼───────────────────────────────────┤\r\n   * │ Dirigido │ Todos los nodos cumplen │ A lo más 1 nodo cumple que:       │\r\n   * │          │ que GE = GS.            │ GS - GE = 1,                      │\r\n   * │          │                         │ Y, a lo más 1 nodo cumple que:    │\r\n   * │          │                         │ GE - GS = 1 (o GS - GE = -1)      │\r\n   * │          │                         │ Y, el resto de nodos cumplen que: │\r\n   * │          │                         │ GE = GS.                          │\r\n   * └──────────┴─────────────────────────┴───────────────────────────────────┘\r\n   * (1): si existen dichos nodos, éstos serían el inicio y el final del camino\r\n   * euleriano.\r\n   */\r\n  get esEuleriano() {\r\n    const nodos = this.nodos;\r\n\r\n    // Condiciones que debe cumplir un grafo dirigido para contener un trayecto\r\n    // euleriano.\r\n    if (this.esDirigido) {\r\n      // Cualquier nodo que cumpla: GS - GE = 1.\r\n      let origen;\r\n\r\n      // Cantidad de nodos que cumplen: GS - GE = 1.\r\n      let candidatosOrigen = 0;\r\n\r\n      // Cantidad de nodos que cumplen: GE - GS = 1.\r\n      let candidatosDestino = 0;\r\n\r\n      for (const nodo of nodos) {\r\n        // GS - GE.\r\n        switch (this.grado(nodo, Direccion.salida) - this.grado(nodo, Direccion.entrada)) {\r\n          case 1:\r\n            candidatosOrigen++;\r\n            origen = nodo;\r\n            break;\r\n\r\n          case -1:\r\n            candidatosDestino++;\r\n            break;\r\n\r\n          // Si el nodo no cumple ninguna de las dos condiciones anteriores,\r\n          // necesariamente tiene que cumplir: GS - GE = 0.\r\n          case 0:\r\n            break;\r\n\r\n          // El grafo no es euleriano.\r\n          default:\r\n            return false;\r\n        }\r\n      }\r\n\r\n      // El grafo contiene sólo un nodo que cumple: GE - GS = 1 y un sólo nodo\r\n      // que cumple: GS - GE = 1. Por lo tanto, se cumple que el grafo\r\n      // contiene un camino euleriano.\r\n      if (candidatosOrigen === 1 && candidatosDestino === 1) {\r\n        return { tipo: Trayecto.camino, origen };\r\n      }\r\n\r\n      // En todos los nodos del grafo se cumple GE = GS. Por lo tanto, se\r\n      // cumple que el grafo contiene un ciclo euleriano. Además, cualquier\r\n      // nodo del grafo puede ser origen del ciclo euleriano.\r\n      return { tipo: Trayecto.ciclo, origen: first(nodos) };\r\n    }\r\n\r\n    // Condiciones que debe cumplir un grafo no dirigido para contener un\r\n    // trayecto euleriano:\r\n\r\n    // Cantidad de nodos de grado impar.\r\n    let impares = 0;\r\n\r\n    // Nodo impar, origen del camino euleriano.\r\n    let impar = 0;\r\n\r\n    // Cuenta la cantidad de nodos de grado impar del grafo. Asigna al\r\n    // último nodo impar como candidato a origen del camino euleriano.\r\n    for (const nodo of nodos) {\r\n      if (this.adyacentes(nodo).length % 2 === 1) {\r\n        impares++;\r\n        impar = nodo;\r\n      }\r\n    }\r\n\r\n    switch (impares) {\r\n      // Si todos los nodos del grafo son de grado par, entonces el grafo\r\n      // contiene un ciclo euleriano. En este caso, cualquier nodo puede ser\r\n      // el nodo origen del ciclo euleriano.\r\n      case 0:\r\n        return { tipo: Trayecto.ciclo, origen: first(nodos) };\r\n\r\n      // Si solo 2 nodos del grafo son de grado impar, entonces el grafo\r\n      // contiene un camino euleriano. Cualquiera de los dos nodos de grado\r\n      // impar puede ser el nodo origen del camino o ciclo euleriano.\r\n      case 2:\r\n        return { tipo: Trayecto.camino, origen: impar };\r\n\r\n      // No existe ningún trayecto euleriano que cubra la totalidad del grafo.\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Obtiene un trayecto euleriano, si el grafo contiene alguno.\r\n   *\r\n   * @param {Trayecto} [tipo=Trayecto.camino] - Tipo de trayecto euleriano.\r\n   * @returns {number[]|boolean} Trayecto euleriano, si el grafo contiene\r\n   * alguno, `false` en caso contrario.\r\n   */\r\n  euleriano(tipo = Trayecto.camino) {\r\n    /**\r\n     * Obtiene un trayecto euleriano de un grafo.\r\n     *\r\n     * @param {number} origen - Nodo que origina el trayecto euleriano.\r\n     * @returns {number[]} Trayecto euleriano del grafo.\r\n     *\r\n     * Implementación del algoritmo de Hierholzer.\r\n     * @see https://www-m9.ma.tum.de/graph-algorithms/hierholzer/index_en.html\r\n     */\r\n    const hierholzer = (origen) => {\r\n      // Trayecto euleriano.\r\n      let euleriano = [];\r\n\r\n      // Copia exacta del grafo, necesaria para eliminar aristas sin alterar\r\n      // el grafo original.\r\n      let grafo = cloneDeep(this);\r\n\r\n      // El algoritmo se repite hasta que todos los nodos del subtrayecto hayan\r\n      // sido insertados en el trayecto euleriano.\r\n      for (let subtrayecto = [origen]; !isEmpty(subtrayecto); ) {\r\n        const actual = last(subtrayecto);\r\n        const adyacentes = grafo.adyacentes(actual);\r\n\r\n        // Si todos los adyacentes del nodo actual han sido insertados en el\r\n        // subtrayecto.\r\n        if (isEmpty(adyacentes)) {\r\n          // Insertar el nodo actual al final del trayecto euleriano.\r\n          euleriano.push(actual);\r\n\r\n          // Eliminar el último nodo (el nodo actual) del final del subtrayecto.\r\n          subtrayecto.pop();\r\n        }\r\n\r\n        // Si aún quedan adyacentes por insertar en el subtrayecto.\r\n        else {\r\n          // Selecciona cualquier adyacente (el 1ero, por ej.).\r\n          const { nodo: siguiente } = first(adyacentes);\r\n\r\n          // Inserta el nodo adyacente al final del subtrayecto.\r\n          subtrayecto.push(siguiente);\r\n\r\n          // Elimina la arista entre el nodo actual y el nodo adyacente.\r\n          grafo.eliminarArista(actual, siguiente);\r\n        }\r\n      }\r\n\r\n      return euleriano.reverse();\r\n    };\r\n\r\n    // Obtiene el tipo de trayecto calculado, y el nodo que origina dicho\r\n    // trayecto.\r\n    const { tipo: calculado, origen } = this.esEuleriano || {};\r\n\r\n    // Si el tipo de trayecto esperado es el calculado, o si es un ciclo\r\n    // (incluso si se esperaba un camino), calcular el trayecto. Esta última\r\n    // condición se debe que, a diferencia de los trayectos hamiltonianos, un\r\n    // ciclo euleriano es un camino euleriano válido.\r\n    if (tipo === calculado || calculado === Trayecto.ciclo) {\r\n      return hierholzer(origen);\r\n    }\r\n\r\n    // No existe ningún trayecto euleriano que cubra la totalidad del grafo.\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Determina si el grafo contiene un trayecto hamiltoniano.\r\n   *\r\n   * @returns {InfoTrayecto|boolean} Tipo de trayecto hamiltoniano y nodo que\r\n   * origina el trayecto, si existe; `false`, en caso contrario.\r\n   *\r\n   * A diferencia de los trayectos eulerianos, no existen condiciones\r\n   * suficientes que cumplan los grafos para determinar si existe un trayecto\r\n   * hamiltoniano. Esto se debe a que, tanto el problema de comprobar la\r\n   * existencia de un trayecto hamiltoniano, como el de encontrar dichos\r\n   * trayectos, son problemas NP-completos, y sus soluciones son polinómicas (y\r\n   * no muy eficientes).\r\n   */\r\n  get esHamiltoniano() {\r\n    const esCamino = Boolean(this.hamiltoniano(Trayecto.camino));\r\n\r\n    if (esCamino) {\r\n      return { tipo: Trayecto.camino };\r\n    }\r\n\r\n    const esCiclo = Boolean(this.hamiltoniano(Trayecto.ciclo));\r\n\r\n    if (esCiclo) {\r\n      return { tipo: Trayecto.ciclo };\r\n    }\r\n\r\n    // No existe ningún trayecto hamiltoniano que cubra la totalidad del grafo.\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Obtiene el trayecto hamiltoniano, si el grafo contiene alguno.\r\n   *\r\n   * @param {Trayecto} [tipo=Trayecto.camino] - Tipo de trayecto hamiltoniano.\r\n   * @returns {number[]|boolean} Trayecto hamiltoniano, si el grafo contiene\r\n   * alguno, `false` en caso contrario.\r\n   *\r\n   * Encontrar cualquier trayecto hamiltoniano en un grafo es un problema\r\n   * NP-completo y, por lo tanto, sus soluciones no son muy eficientes. La\r\n   * implementación, en este caso, se realiza generando una permutación de la\r\n   * lista de nodos por iteración, y retornando la primera que sea un trayecto\r\n   * hamiltoniano válido. En el peor de los casos, la complejidad temporal de\r\n   * ésta implementación es O(n * n!).\r\n   */\r\n  hamiltoniano(tipo = Trayecto.camino) {\r\n    for (let permutacion of permutar(this.nodos)) {\r\n      // Si el trayecto es un ciclo, se agrega al final de la permutación el\r\n      // primer elemento de ésta. Así, se cumple la condicición de ciclo: el\r\n      // trayecto termina en el mismo nodo que lo originó.\r\n      if (tipo === Trayecto.ciclo) {\r\n        permutacion.push(first(permutacion));\r\n      }\r\n\r\n      if (this.esTrayecto(permutacion)) {\r\n        return permutacion;\r\n      }\r\n    }\r\n\r\n    // No existe ningún trayecto hamiltoniano que cubra la totalidad del grafo.\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Calcula el flujo máximo desde el nodo entrada hasta el nodo salida.\r\n   *\r\n   * @param {number} entrada - Nodo entrada.\r\n   * @param {number} salida - Nodo salida.\r\n   * @returns {number} Flujo máximo desde el nodo entrada hasta el nodo salida.\r\n   *\r\n   * Implementación del algoritmo de Edmonds-Karp, que a su vez es una\r\n   * implementación del algoritmo de Ford-Fulkerson, utilizando búsqueda en\r\n   * anchura (breadth-first search, BFS).\r\n   */\r\n  flujoMaximo(entrada, salida) {\r\n    // Flujo máximo inicial.\r\n    let flujo = 0;\r\n\r\n    // Matriz de capacidad residual (peso de cada arista menos el flujo de cada\r\n    // camino de aumento, CA).\r\n    let capacidad = this.matrizDeAdyacencia;\r\n\r\n    // Se itera hasta no encontrar más caminos de aumento (CA) en el grafo.\r\n    // En este caso, un CA es cualquier camino simple que atraviese las aristas\r\n    // cuya capacidad residual sea positiva.\r\n    while (true) {\r\n      // Busca un CA en el grafo y retorna la capacidad residual mínima del CA\r\n      // encontrado, más la lista de padres de cada nodo que compone el CA.\r\n      let { flujoCamino, padre } = caminoDeAumento(this, entrada, salida, capacidad);\r\n\r\n      // Si ya no existen más CA, se termina la iteración.\r\n      if (flujoCamino === 0) {\r\n        break;\r\n      }\r\n\r\n      // Aumentar el flujo máximo en la cantidad de flujo del CA encontrado.\r\n      flujo += flujoCamino;\r\n\r\n      // Se recorre inversamente el CA (desde la salida hasta la entrada),\r\n      // actualizando las capacidades residuales de cada arista (y sus inversas)\r\n      // del CA.\r\n      for (let actual = salida; actual !== entrada; actual = padre[actual]) {\r\n        let anterior = padre[actual];\r\n\r\n        // Aumentar la capacidad residual de la arista {actual, anterior} en la\r\n        // capacidad residual mínima del CA.\r\n        capacidad[actual][anterior] += flujoCamino;\r\n\r\n        // Reducir la capacidad residual del inverso de la arista anterior en la\r\n        // misma cantidad que se aumentó ésta última.\r\n        capacidad[anterior][actual] -= flujoCamino;\r\n      }\r\n    }\r\n\r\n    return flujo;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} ArbolGeneradorMinimo\r\n   *   @property {Arista[]} arbol - Lista de aristas del árbol generador mínimo.\r\n   *   @property {number} distancia - Distancia total del árbol generador\r\n   *   mínimo.\r\n   */\r\n  /**\r\n   * Construye un árbol generador mínimo del grafo.\r\n   *\r\n   * @returns {ArbolGeneradorMinimo} Árbol generador mínimo del grafo.\r\n   *\r\n   * Implementación del algoritmo de Kruskal, utilizando la estructura de\r\n   * conjuntos disjuntos.\r\n   */\r\n  get arbolGeneradorMinimo() {\r\n    let arbol = [];\r\n    let conjunto = new ConjuntoDisjunto();\r\n\r\n    // Crea un conjunto disjunto por cada nodo del grafo.\r\n    for (const nodo of this.nodos) {\r\n      conjunto.crear(nodo);\r\n    }\r\n\r\n    // Ordena la lista de aristas según sus pesos, ascendentemente.\r\n    let aristas = this.listaDeAristas.sort((a, b) => a.peso - b.peso);\r\n\r\n    for (const arista of aristas) {\r\n      // Se sigue la cadena de nodos padres de un nodo hasta llegar a la raíz\r\n      // que representa al conjunto que contiene dicho nodo.\r\n      const raizOrigen = conjunto.buscar(arista.origen);\r\n      const raizDestino = conjunto.buscar(arista.destino);\r\n\r\n      // Si la raíz del nodo origen no pertenece al mismo conjunto de la raíz\r\n      // del nodo destino, entonces la arista que une los nodos origen y destino\r\n      // no forma un ciclo con el resto de las aristas del árbol, por lo que\r\n      // puede ser agregada al árbol.\r\n      if (raizOrigen !== raizDestino) {\r\n        arbol.push(arista);\r\n\r\n        // Une el conjunto de la raíz del nodo origen con el conjunto de la raíz\r\n        // del nodo destino.\r\n        conjunto.unir(raizOrigen, raizDestino);\r\n      }\r\n    }\r\n\r\n    // Retorna el árbol y la distancia total del árbol (suma total de los pesos\r\n    // de las aristas del árbol). Si las aristas no son ponderadas, considerar\r\n    // peso 1 por defecto.\r\n    return {\r\n      arbol,\r\n      distancia: sumBy(arbol, (arista) => arista.peso ?? 1),\r\n    };\r\n  }\r\n}\r\n\r\nexport { Grafo, Celda, Trayecto };\r\n","import { Box, Button, FormControl, TextField } from '@material-ui/core';\r\nimport React from 'react';\r\nimport DeleteIcon from '@material-ui/icons/Delete';\r\n\r\n\r\nconst RowLink = ({ onChange, onRemove, from, to, text }) => {\r\n    \r\n    return (\r\n        <FormControl m={10}>\r\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\r\n                <TextField\r\n                    id='filled-number'\r\n                    label='Desde'\r\n                    type='number'\r\n                    value={from}\r\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                    InputLabelProps={{\r\n                        shrink: true,\r\n                    }}\r\n                    onChange={e => onChange('from', e.target.value)}\r\n                />\r\n                <TextField\r\n                    id='filled-number'\r\n                    label='Hasta'\r\n                    type='number'\r\n                    value={to}\r\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                    InputLabelProps={{\r\n                        shrink: true,\r\n                    }}\r\n                    onChange={e => onChange('to', e.target.value)}\r\n                />\r\n\r\n                <TextField\r\n                    id='filled-number'\r\n                    label='Peso'\r\n                    type='number'\r\n                    value={text}\r\n                    InputLabelProps={{\r\n                        shrink: true\r\n                    }}\r\n                    InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                    onChange={e => onChange( 'text', e.target.value )}\r\n                />\r\n                <Button\r\n                    size='small'\r\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\r\n                    onClick={onRemove}\r\n                >\r\n                </Button>\r\n            </Box>\r\n        </FormControl>\r\n    );\r\n};\r\n\r\nexport default RowLink;","import { Box, Button, FormControl, TextField } from '@material-ui/core';\r\nimport React from 'react';\r\nimport DeleteIcon from '@material-ui/icons/Delete';\r\n\r\nconst Row = ({ onChange, onRemove, text }) => {\r\n\r\n    return (\r\n        <FormControl className='main_formControl'>\r\n            <Box display='flex' width='100%' justifyContent='space-between' p={1}>\r\n                <TextField\r\n                    fullWidth='true'\r\n                    className='main_textField'\r\n                    label='Nombre del nodo'\r\n                    value={text}\r\n                    onChange={e => onChange('text', e.target.value)}\r\n                />\r\n                <Button\r\n                    size='small'\r\n                    startIcon={<DeleteIcon className='main_deleteIcon' style={{ fontSize: 25 }} />}\r\n                    onClick={onRemove}\r\n                >\r\n                </Button>\r\n            </Box>\r\n        </FormControl>\r\n    );\r\n}\r\n\r\nexport default Row;","import React, { useState } from 'react';\r\nimport { Box, Button, TextField } from '@material-ui/core';\r\nimport Content from './Content';\r\nimport RefreshIcon from '@material-ui/icons/Refresh';\r\nimport { Grafo, Trayecto } from '../lib/grafo/grafo.js';\r\nimport { Arista } from '../lib/grafo/arista.js';\r\nimport { SaveAlt } from '@material-ui/icons';\r\nimport swal from 'sweetalert';\r\nimport CachedIcon from '@material-ui/icons/Cached';\r\nimport RowLink from './RowLink';\r\nimport Row from './Row';\r\n\r\nimport { Debugout } from 'debugout.js';\r\n\r\nconst bugout = new Debugout();\r\n\r\nconst Main = () => {\r\n\r\n    const downloadLogs = (e) => {\r\n        e.preventDefault();\r\n        bugout.info('Descarga de logs', bugout.realTimeLoggingOn);\r\n        bugout.downloadLog();\r\n    }\r\n\r\n    bugout.info('Acceso a sección de grafos dirigidos');\r\n\r\n    const defaultState = {\r\n        text: '',\r\n        color: 'lightskyblue',\r\n    };\r\n\r\n    const defaultStateLinks = {\r\n        from: '',\r\n        to: '',\r\n        text: '',\r\n    };\r\n    const [rows, setRows] = useState([defaultState]); //nodos\r\n    const [links, setLinks] = useState([defaultStateLinks]);\r\n    const [doneFetch, setDoneFetch] = useState(false);\r\n    const [doneFetchDistance, setDoneFetchDistance] = useState(false);\r\n    const [doneFetchHamEul, setDoneFetchHamEul] = useState(false);\r\n    const [doneFetchFlujoMaximo, setDoneFetchFlujoMaximo] = useState(false);\r\n    const [doneFetchArbol, setDoneFetchArbol] = useState(false);\r\n    const [changeData, setChangeData] = useState({\r\n        desde: '',\r\n        hasta: '',\r\n    })\r\n    const [changePeakData, setChangePeakData] = useState({\r\n        from: '',\r\n        to: '',\r\n    });\r\n    const [edgesClass, setEdgesClass] = useState([]);\r\n    const [grafo, setGrafo] = useState([]);\r\n    const [arbolGenerador, setArbolGenerador] = useState([])\r\n    const [matrizDeCamino, setMatrizDeCamino] = useState([]);\r\n    const [saveAllData, setSaveAllData] = useState(false)\r\n    const [isHamiltoniano, setIsHamiltoniano] = useState(false);\r\n    const [isEuleriano, setIsEuleriano] = useState(false);\r\n    const [isConexo, setIsConexo] = useState(false);\r\n    const [distance, setDistance] = useState();\r\n    const [shortPath, setShortPath] = useState([]);\r\n    const [distanceFrom, setDistanceFrom] = useState(0);\r\n    const [distanceTo, setDistanceTo] = useState(0);\r\n    const [peakFlowFrom, setPeakFlowFrom] = useState(0);\r\n    const [peakFlowTo, setPeakFlowTo] = useState(0);\r\n    const [peakFlow, setPeakFlow] = useState();\r\n    const [validation, setValidation] = useState(false);\r\n    const [eulerianPath, setEulerianPath] = useState([]);\r\n    const [eulerianCycle, setEulerianCycle] = useState([]);\r\n    const [hamiltonianPath, setHamiltonianPath] = useState([]);\r\n    const [hamiltonianCycle, setHamiltonianCycle] = useState([]);\r\n\r\n    const saveArista = (from, to, peso) => {\r\n\r\n        const edge = new Arista(from, to, peso);\r\n        setEdgesClass(edgesClass.concat(edge));\r\n        grafoClass(from, to, peso)\r\n\r\n    };\r\n\r\n    const grafoClass = (from, to, peso) => {\r\n        const numberFrom = Number(from);\r\n        const numberTo = Number(to);\r\n        const numberPeso = Number(peso);\r\n        const listaDeAristas = [\r\n            new Arista(numberFrom, numberTo, numberPeso),\r\n        ];\r\n        setGrafo(grafo.concat(listaDeAristas));\r\n    };\r\n\r\n    const previewValidation = () => {\r\n        (rows[0].length === 0 || links[0].from.length === 0) ? (\r\n            swal('Campos vacíos', 'Para continuar con la aplicación, debes completar los campos vacíos', 'error')\r\n        ) : setValidation(true);\r\n    };\r\n\r\n    const handleArbol = () => {\r\n        !doneFetchArbol ? (setDoneFetchArbol(true)) : setDoneFetchArbol(false);\r\n    }\r\n\r\n    const handleFlujoMaximo = () => {\r\n        !doneFetchFlujoMaximo ? (setDoneFetchFlujoMaximo(true)) : setDoneFetchFlujoMaximo(false);\r\n    }\r\n\r\n    const handleDistance = () => {\r\n        !doneFetchDistance ? (setDoneFetchDistance(true)) : setDoneFetchDistance(false);\r\n\r\n    }\r\n\r\n    const handleHamEul = () => {\r\n        !doneFetchHamEul ? (setDoneFetchHamEul(true)) : setDoneFetchHamEul(false);\r\n    }\r\n\r\n\r\n\r\n    const handleMatriz = () => {\r\n        !doneFetch ? (setDoneFetch(true)) : setDoneFetch(false);\r\n    }\r\n\r\n\r\n    const saveData = () => {\r\n        previewValidation();\r\n        if (validation === true) {\r\n            setSaveAllData(true);\r\n            const gra = Grafo.desdeListaDeAristas(grafo, true);\r\n            const { esEuleriano, esHamiltoniano, esConexo, matrizDeCaminos, arbolGeneradorMinimo: agm } = gra;\r\n            const { camino: shortPathGraph, distancia: distanceShortes } = gra.caminoMasCorto(distanceFrom, distanceTo);\r\n            const peak = gra.flujoMaximo(peakFlowFrom, peakFlowTo);\r\n\r\n            setArbolGenerador(agm.arbol.map((arista) => arista.link));\r\n            setMatrizDeCamino(matrizDeCaminos);\r\n            setIsHamiltoniano(esHamiltoniano);\r\n            setIsEuleriano(esEuleriano);\r\n            setIsConexo(esConexo);\r\n            setDistance(distanceShortes);\r\n            setShortPath(shortPathGraph);\r\n            setPeakFlow(peak);\r\n            setEulerianPath(gra.euleriano(Trayecto.camino))\r\n            setEulerianCycle(gra.euleriano(Trayecto.ciclo))\r\n            setHamiltonianPath(gra.hamiltoniano(Trayecto.camino))\r\n            setHamiltonianCycle(gra.hamiltoniano(Trayecto.ciclo));\r\n            bugout.info('Guardado de información para la generación del grafo');\r\n\r\n\r\n        } else bugout.error('Ha ocurrido un error en la validación de los datos');\r\n\r\n\r\n    };\r\n\r\n    function refreshPage(e) {\r\n        e.preventDefault()\r\n        window.location.reload();\r\n        bugout.info('Recarga de página');\r\n\r\n    }\r\n\r\n\r\n    const handleOnChange = (index, text, value) => {\r\n        const copyRows = [...rows];\r\n        const key = index;\r\n        copyRows[index] = {\r\n            ...copyRows[index],\r\n            key,\r\n            [text]: value\r\n        };\r\n        setRows(copyRows);\r\n        bugout.info('Has cambiado algún valor de los nodos');\r\n\r\n    };\r\n\r\n\r\n    const handleOnAdd = () => {\r\n        let len = rows.length - 1;\r\n        rows[len].text.length > 0 ? setRows(rows.concat(defaultState)) : swal('Error en los nodos', 'Campos vacíos, por favor asigne nombre a los nodos creados', 'error');\r\n    };\r\n\r\n    const handleOnAddLink = () => {\r\n        let len = links.length - 1;\r\n        (links[len].from.length > 0 || links[len].to.length > 0 || links[len].text.length > 0) ? (\r\n            setLinks(links.concat(defaultState))\r\n        ) : swal('Error en los links', 'Campos vacíos en los links, por favor complete los datos antes de continuar', 'error');\r\n    };\r\n\r\n    const handleOnRemove = index => {\r\n        if (rows.length === 1) {\r\n            swal('Error en los nodos', 'No se puede eliminar el único campo de nodos', 'error')\r\n        } else {\r\n            const copyRows = [...rows];\r\n            copyRows.splice(index, 1);\r\n            setRows(copyRows);\r\n        }\r\n\r\n        saveData();\r\n        bugout.warn('Has borrado un campo de los nodos');\r\n\r\n    };\r\n\r\n    const handleOnChangeLinks = (index, from, value, text, to) => {\r\n        const copyLinks = [...links];\r\n        copyLinks[index] = {\r\n            ...copyLinks[index],\r\n            [from]: value,\r\n            [to]: value,\r\n            [text]: value,\r\n        };\r\n        setLinks(copyLinks);\r\n        if (copyLinks[index].from && copyLinks[index].to && copyLinks[index].text)\r\n            saveArista(copyLinks[index].from, copyLinks[index].to, copyLinks[index].text);\r\n        bugout.info('Has cambiado algún valor de los links');\r\n\r\n    };\r\n\r\n    const handleOnRemoveLink = index => {\r\n        if (links.length === 1) {\r\n            swal(\"Error en los links\", 'No se puede eliminar el único elemento de los links', 'error');\r\n            bugout.error('No se puede eliminar el único elemento de los links');\r\n\r\n        } else {\r\n            const copyLinks = [...links];\r\n            copyLinks.splice(index, 1);\r\n            setLinks(copyLinks);\r\n        }\r\n        saveData();\r\n        bugout.info('Link eliminado correctamente');\r\n\r\n    };\r\n\r\n    const handleSubmitFromTo = (e) => {\r\n        e.preventDefault();\r\n        getFromTo(changeData)\r\n    };\r\n\r\n    const handleInputChangeFromTo = (e) => {\r\n        e.preventDefault();\r\n        setChangeData({\r\n            ...changeData,\r\n            [e.target.name]: e.target.value,\r\n        });\r\n        bugout.info('Datos de distancia entre dos nodos actualizada');\r\n\r\n    };\r\n\r\n    const handleSubmitPeak = (e) => {\r\n        e.preventDefault();\r\n        peakFlowFromTo(changePeakData);\r\n    };\r\n\r\n    const peakFlowFromTo = ({ from, to }) => {\r\n        if (from && to) {\r\n            setPeakFlowFrom(Number(from));\r\n            setPeakFlowTo(Number(to));\r\n        }\r\n        bugout.info('Datos de flujo máximo actualizados');\r\n\r\n\r\n    };\r\n\r\n    const getFromTo = ({ desde, hasta }) => {\r\n        if (desde && hasta) {\r\n            setDistanceFrom(Number(desde));\r\n            setDistanceTo(Number(hasta));\r\n        }\r\n    };\r\n\r\n    const handleInputPeakFlow = (e) => {\r\n        e.preventDefault();\r\n        setChangePeakData({\r\n            ...changePeakData,\r\n            [e.target.name]: e.target.value,\r\n        })\r\n    };\r\n\r\n    return (\r\n        <Box display='flex' className='main_view'>\r\n            <div className='main_options'>\r\n                <Button m={10} variant='contained' color='secondary' onClick={handleOnAdd}>Agregar</Button>\r\n                {rows.map((row, index) => {\r\n                    bugout.info('Se ha creado un nuevo nodo');\r\n                    return (\r\n                        <Row\r\n                            {...row}\r\n                            className='main_row'\r\n                            onChange={(text, value) => handleOnChange(index, text, value)}\r\n                            onRemove={() => handleOnRemove(index)}\r\n                            key={index}\r\n                        />\r\n                    )\r\n                })}\r\n\r\n                <hr />\r\n                <Button m={10} variant='contained' color='grey' onClick={handleOnAddLink}>Agregar link</Button>\r\n                {links.map((link, index) => {\r\n                    bugout.info('Se ha creado un nuevo link');\r\n                    return (\r\n                        <RowLink\r\n                            {...link}\r\n                            className='main_row'\r\n                            onChange={(from, to, value, text) => handleOnChangeLinks(index, from, to, value, text)}\r\n                            onRemove={() => handleOnRemoveLink(index)}\r\n                            key={index}\r\n                        />\r\n                    )\r\n                })}\r\n\r\n                <div>\r\n                    {\r\n                        (links.length < 1 || rows.length < 1) ? (\r\n                            <Button m={10}\r\n                                className='main_row'\r\n                                variant='contained'\r\n                                color='primary'\r\n                                disabled\r\n                            >\r\n                                GUARDAR DATOS\r\n                                <SaveAlt />\r\n                            </Button>\r\n                        ) : (\r\n                            <Button m={10}\r\n                                className='main_row'\r\n                                variant='contained'\r\n                                color='primary'\r\n                                onClick={saveData}\r\n                            >\r\n                                GUARDAR DATOS\r\n                                <SaveAlt />\r\n                            </Button>\r\n                        )\r\n                    }\r\n                </div>\r\n\r\n                {/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleMatriz}\r\n                            disabled\r\n                        >\r\n                            MATRIZ DE CAMINO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleMatriz}\r\n                        >\r\n                            MATRIZ DE CAMINO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetch === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n\r\n                    <div className=\"item\">\r\n                        {\r\n                            matrizDeCamino &&\r\n                            matrizDeCamino.map((item, index) => {\r\n                                return (\r\n                                    <div className=\"main_boxItem\">\r\n                                        <p>{index}</p>\r\n                                        {bugout.info('Acceso a sección Matriz de camino')}\r\n                                        {\r\n                                            item.map(miniItem => (\r\n                                                <div className=\"main_boxMiniItem\">\r\n                                                    <p className='main_p'>{miniItem} &nbsp; </p>\r\n                                                </div>\r\n                                            ))\r\n\r\n                                        }\r\n                                    </div>\r\n                                )\r\n                            })\r\n                        }\r\n                        <p className='main_isConexo'>\r\n                            {\r\n                                (isConexo === true) ? ('El grafo es conexo') : ('El grafo no es conexo')\r\n                            }\r\n                        </p>\r\n                    </div>\r\n                </div >\r\n                {/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\r\n\r\n\r\n                {/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleDistance}\r\n                            disabled\r\n                        >\r\n                            DISTANCIA ENTRE DOS NODOS\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleDistance}\r\n\r\n                        >\r\n                            DISTANCIA ENTRE DOS NODOS\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={doneFetchDistance === true ? ('main_isMatriz') : 'main_noMatriz'}>\r\n                    <form className='main_formDistance' onSubmit={handleSubmitFromTo}>\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number'\r\n                            label='Desde'\r\n                            type='number'\r\n                            name='desde'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputChangeFromTo}\r\n                            InputLabelProps={{\r\n                                shrink: true,\r\n                            }}\r\n                        />\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number'\r\n                            label='Hasta'\r\n                            type='number'\r\n                            name='hasta'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputChangeFromTo}\r\n                            InputLabelProps={{ shrink: true, }}\r\n                        />\r\n\r\n                        <Button\r\n                            variant='contained'\r\n                            color='primary'\r\n                            type='submit'\r\n                            onClick={saveData}\r\n                        ><RefreshIcon />\r\n                        </Button>\r\n                    </form>\r\n                    {\r\n                        changeData.desde && changeData.hasta ? (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Los nodos recorridos son los siguientes: </p>\r\n                                {bugout.info('Acceso sección de Distancia entre dos nodos')}\r\n                                {\r\n                                    shortPath.map(item => (\r\n                                        <p className='main_distanceItem'>{item}</p>\r\n                                    ))}\r\n                                <p>\r\n                                    Distancia : {distance}\r\n                                </p>\r\n                            </div>\r\n                        ) : bugout.error('Ocurrió un error al momento de desplegar la información de distancia entre dos nodos')\r\n\r\n                    }\r\n\r\n                </div >\r\n                {/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\r\n\r\n                {/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleHamEul}\r\n                            disabled\r\n                        >\r\n                            HAMILTONIANO Y/O EULERIANO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleHamEul}\r\n                        >\r\n                            HAMILTONIANO Y/O EULERIANO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchHamEul === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <div className='distanceFromTo'>\r\n                    {bugout.info('Acceso sección de Hamiltoniano/Euleriano')}\r\n\r\n                        <p>\r\n                            {\r\n                                !isHamiltoniano ? ('El grafo no es hamiltoniano') : ('El grafo es hamiltoninao')\r\n                            }\r\n\r\n                            {\r\n                                hamiltonianCycle ? (\r\n                                    <>\r\n                                        <p>Tiene como ciclo: </p>\r\n                                        {\r\n                                            hamiltonianCycle.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay ciclo euleriano')\r\n                            }\r\n\r\n                            {\r\n                                hamiltonianPath ? (\r\n                                    <>\r\n                                        <p>Tiene como camino: </p>\r\n                                        {\r\n                                            hamiltonianPath.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay camino hamiltoniano')\r\n                            }\r\n\r\n                        </p>\r\n                        <p>\r\n                            {\r\n                                !isEuleriano ? ('El grafo no es euleriano') : ('El grafo es euleriano')\r\n                            }\r\n\r\n                            {\r\n                                eulerianCycle ? (\r\n                                    <>\r\n                                        <p>Tiene como ciclo: </p>\r\n                                        {\r\n                                            eulerianCycle.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay ciclo euleriano')\r\n                            }\r\n\r\n                            {\r\n                                eulerianPath ? (\r\n                                    <>\r\n                                        <p>Tiene como camino: </p>\r\n                                        {\r\n                                            eulerianPath.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay camino euleriano')\r\n\r\n                            }\r\n                        </p>\r\n                    </div>\r\n                </div >\r\n                {/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\r\n\r\n\r\n                {/* ------------------------ FLUJO MÁXIMO ------------------------ */}\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleFlujoMaximo}\r\n                            disabled\r\n                        >\r\n                            FLUJO MÁXIMO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleFlujoMaximo}\r\n                        >\r\n                            FLUJO MÁXIMO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchFlujoMaximo === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <form className='main_formDistance' onSubmit={handleSubmitPeak}>\r\n                        {bugout.info('Acceso sección de Flujo máximo')}\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number-peak'\r\n                            label='Desde'\r\n                            type='number'\r\n                            name='from'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputPeakFlow}\r\n                            InputLabelProps={{\r\n                                shrink: true,\r\n                            }}\r\n                        />\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number-peak'\r\n                            label='Hasta'\r\n                            type='number'\r\n                            name='to'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputPeakFlow}\r\n                            InputLabelProps={{ shrink: true, }}\r\n                        />\r\n                        <Button\r\n                            variant='contained'\r\n                            color='gray'\r\n                            type='submit'\r\n                            onClick={saveData}\r\n                        ><RefreshIcon />\r\n                        </Button>\r\n                    </form>\r\n                    {\r\n                        changePeakData.from && changePeakData.to ? (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Flujo máximo es: {peakFlow}</p>\r\n                                {bugout.info('Acceso sección de Flujo máximo')}\r\n                            </div>\r\n                        ) : (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Flujo máximo resultante es: {peakFlow}</p>\r\n                            </div>\r\n                        )\r\n                    }\r\n                </div >\r\n\r\n                {/* ------------------------ FLUJO MÁXIMO ------------------------ */}\r\n\r\n                {/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button\r\n                            m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleArbol}\r\n                            disabled\r\n                        >\r\n                            ÁRBOL GENERADOR\r\n                        </Button>\r\n                    ) : (\r\n                        <Button\r\n                            m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleArbol}\r\n                        >\r\n                            ÁRBOL GENERADOR\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchArbol === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <div className='main_contentInside'>\r\n                        {\r\n                            arbolGenerador &&\r\n                            <Content data={rows} linksData={arbolGenerador} />\r\n                        }\r\n                        {bugout.info('Acceso sección de Árbol generador')}\r\n\r\n                    </div>\r\n                </div >\r\n\r\n                {/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\r\n\r\n                <Button type=\"button\" onClick={refreshPage}> Recargar la página <span><CachedIcon className='main_reloadIcon' /></span> </Button>\r\n                <Button type='button' onClick={downloadLogs}>Obtener registro de actividad</Button>\r\n            </div >\r\n\r\n            <Content data={rows} linksData={links} />\r\n        </Box >\r\n    )\r\n}\r\n\r\n\r\nexport default Main;\r\n","import React from 'react';\r\nimport { AppBar, Toolbar } from '@material-ui/core'\r\nimport { Link } from 'react-router-dom';\r\nconst Header = () => (\r\n    <AppBar position='static'>\r\n        <Toolbar className='header_header'>\r\n            <Link to='/'>\r\n                <h3 className='header_title'>App Grafos</h3>\r\n            </Link>\r\n            <div className='initalPage_item'>\r\n                <Link to='/documentacion'>\r\n                    DOCUMENTACIÓN\r\n                </Link>\r\n            </div>\r\n            \r\n        </Toolbar>\r\n\r\n\r\n    </AppBar>\r\n\r\n)\r\n\r\nexport default Header;\r\n","import React from 'react';\r\nimport * as go from 'gojs';\r\nimport { ReactDiagram } from 'gojs-react';\r\n\r\n// https://gojs.net/latest/samples/dragUnoccupied.html\r\nfunction avoidNodeOverlap(node, pt, gridpt) {\r\n  function isUnoccupied(r, node) {\r\n    let diagram = node.diagram;\r\n\r\n    function navig(obj) {\r\n      let part = obj.part;\r\n      if (part === node) return null;\r\n      if (part instanceof go.Link) return null;\r\n      if (part.isMemberOf(node)) return null;\r\n      if (node.isMemberOf(part)) return null;\r\n      return part;\r\n    }\r\n\r\n    let lit = diagram.layers;\r\n    while (lit.next()) {\r\n      let lay = lit.value;\r\n      if (lay.isTemporary) continue;\r\n      if (lay.findObjectsIn(r, navig, null, true).count > 0) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  \r\n\r\n  if (node.diagram instanceof go.Palette) return gridpt;\r\n  let bnds = node.actualBounds;\r\n  let loc = node.location;\r\n  let r = new go.Rect(\r\n    gridpt.x - (loc.x - bnds.x),\r\n    gridpt.y - (loc.y - bnds.y),\r\n    bnds.width,\r\n    bnds.height\r\n  );\r\n\r\n  r.inflate(-0.5, -0.5);\r\n\r\n  if (\r\n    !(node.diagram.currentTool instanceof go.DraggingTool) &&\r\n    (!node._temp || !node.layer.isTemporary)\r\n  ) {\r\n    node._temp = true;\r\n    while (!isUnoccupied(r, node)) {\r\n      r.x += 10;\r\n      r.y += 2;\r\n    }\r\n    r.inflate(0.5, 0.5);\r\n    return new go.Point(r.x - (loc.x - bnds.x), r.y - (loc.y - bnds.y));\r\n  }\r\n  if (isUnoccupied(r, node)) return gridpt;\r\n  return loc;\r\n}\r\n\r\nfunction FDLayout() {\r\n  go.ForceDirectedLayout.call(this);\r\n}\r\n\r\ngo.Diagram.inherit(FDLayout, go.ForceDirectedLayout);\r\n\r\nFDLayout.prototype.makeNetwork = function (coll) {\r\n  let net = go.ForceDirectedLayout.prototype.makeNetwork.call(this, coll);\r\n\r\n  net.vertexes.each(function (vertex) {\r\n    let node = vertex.node;\r\n    if (node !== null) vertex.isFixed = node.isSelected;\r\n  });\r\n\r\n  return net;\r\n};\r\n\r\nfunction initDiagram() {\r\n  const $ = go.GraphObject.make;\r\n  const diagram = $(go.Diagram, {\r\n    \"undoManager.isEnabled\": true,\r\n    \"clickCreatingTool.archetypeNodeData\": { text: \"new node\", color: \"lightblue\", fig: \"Cloud\" },\r\n    initialAutoScale: go.Diagram.Uniform, // Zoom to make everything fit in the viewport.\r\n    layout: $(go.CircularLayout),\r\n    model: $(go.GraphLinksModel, {\r\n      linkKeyProperty: \"key\",\r\n    }),\r\n  });\r\n\r\n  diagram.nodeTemplate = $(\r\n    go.Node,\r\n    \"Auto\", // the Shape will go around the TextBlock\r\n    new go.Binding(),\r\n    $(\r\n      go.Shape,\r\n      \"Circle\",\r\n      { name: \"SHAPE\", fill: \"white\", strokeWidth: 1, portId: \"\", },\r\n      // Shape.fill is bound to Node.data.color\r\n      new go.Binding(\"fill\", \"color\")\r\n    ),\r\n    $(\r\n      go.TextBlock,\r\n      { margin: 10, editable: false, font: \"26px Verdana\" },\r\n      new go.Binding(\"text\").makeTwoWay()\r\n    ),\r\n    { dragComputation: avoidNodeOverlap }\r\n  );\r\n\r\n    var lay = diagram.layout;\r\n\r\n    var spacing = 200;\r\n    spacing = parseFloat(spacing, 200);\r\n    lay.spacing = spacing;\r\n  \r\n    lay = go.CircularLayout.ConstantSpacing;\r\n\r\n\r\n  diagram.linkTemplate =\r\n    $(go.Link,\r\n      $(go.Shape),\r\n      $(\r\n        go.TextBlock,\r\n        { font: \"24px Verdana\", segmentOffset: new go.Point(0, -20) },\r\n        new go.Binding(\"text\", \"text\")\r\n      )\r\n    );\r\n\r\n  return diagram;\r\n}\r\n\r\n\r\nconst NotDirected = ({ data, linksData }) => {\r\n  return (\r\n    <div className=\"content\">\r\n      <ReactDiagram\r\n        initDiagram={initDiagram}\r\n        divClassName='diagram-component'\r\n        nodeDataArray={data}\r\n        linkDataArray={linksData}\r\n      />\r\n    </div>\r\n  )\r\n}\r\nexport default NotDirected;","import React, { useState } from 'react';\r\nimport { Box, Button, TextField } from '@material-ui/core';\r\nimport RefreshIcon from '@material-ui/icons/Refresh';\r\nimport { Grafo, Trayecto } from '../lib/grafo/grafo.js';\r\nimport { Arista } from '../lib/grafo/arista.js';\r\nimport { SaveAlt } from '@material-ui/icons';\r\nimport swal from 'sweetalert';\r\nimport CachedIcon from '@material-ui/icons/Cached';\r\nimport NotDirected from './NotDirected.js';\r\nimport RowLink from './RowLink';\r\nimport Row from './Row';\r\n\r\nimport { Debugout } from 'debugout.js';\r\nconst bugout = new Debugout();\r\n\r\n\r\nconst MainNotDirected = () => {\r\n\r\n    const downloadLogs = (e) => {\r\n        e.preventDefault();\r\n        bugout.info('Descarga de logs', bugout.realTimeLoggingOn);\r\n        bugout.downloadLog();\r\n    };\r\n\r\n    bugout.info('Acceso a sección de grafos no dirigidos');\r\n\r\n    const defaultState = {\r\n        text: '',\r\n        color: 'lightskyblue',\r\n    };\r\n\r\n    const defaultStateLinks = {\r\n        from: '',\r\n        to: '',\r\n        text: '',\r\n    };\r\n    const [rows, setRows] = useState([defaultState]); //nodos\r\n    const [links, setLinks] = useState([defaultStateLinks]);\r\n    const [doneFetch, setDoneFetch] = useState(false);\r\n    const [doneFetchDistance, setDoneFetchDistance] = useState(false);\r\n    const [doneFetchHamEul, setDoneFetchHamEul] = useState(false);\r\n    const [doneFetchFlujoMaximo, setDoneFetchFlujoMaximo] = useState(false);\r\n    const [doneFetchArbol, setDoneFetchArbol] = useState(false);\r\n    const [changeData, setChangeData] = useState({\r\n        desde: '',\r\n        hasta: '',\r\n    })\r\n    const [changePeakData, setChangePeakData] = useState({\r\n        from: '',\r\n        to: '',\r\n    });\r\n    // Creando aristas usando la clase Arista\r\n    const [edgesClass, setEdgesClass] = useState([]);\r\n    const [grafo, setGrafo] = useState([]);\r\n    const [arbolGenerador, setArbolGenerador] = useState([])\r\n    const [matrizDeCamino, setMatrizDeCamino] = useState([]);\r\n    const [saveAllData, setSaveAllData] = useState(false)\r\n    const [isHamiltoniano, setIsHamiltoniano] = useState(false);\r\n    const [isEuleriano, setIsEuleriano] = useState(false);\r\n    const [isConexo, setIsConexo] = useState(false);\r\n    //camino más corto\r\n    const [distance, setDistance] = useState();\r\n    const [shortPath, setShortPath] = useState([]);\r\n    const [distanceFrom, setDistanceFrom] = useState(0);\r\n    const [distanceTo, setDistanceTo] = useState(0);\r\n    const [peakFlowFrom, setPeakFlowFrom] = useState(0);\r\n    const [peakFlowTo, setPeakFlowTo] = useState(0);\r\n    const [peakFlow, setPeakFlow] = useState();\r\n    const [validation, setValidation] = useState(false);\r\n    const [eulerianPath, setEulerianPath] = useState([]);\r\n    const [eulerianCycle, setEulerianCycle] = useState([]);\r\n    const [hamiltonianPath, setHamiltonianPath] = useState([]);\r\n    const [hamiltonianCycle, setHamiltonianCycle] = useState([]);\r\n\r\n    const saveArista = (from, to, peso) => {\r\n\r\n        const edge = new Arista(from, to, peso);\r\n        setEdgesClass(edgesClass.concat(edge));\r\n        grafoClass(from, to, peso)\r\n\r\n    };\r\n\r\n    // grafoClass => función para poder crear\r\n    const grafoClass = (from, to, peso) => {\r\n        const numberFrom = Number(from);\r\n        const numberTo = Number(to);\r\n        const numberPeso = Number(peso);\r\n\r\n        const listaDeAristas = [\r\n            new Arista(numberFrom, numberTo, numberPeso),\r\n        ];\r\n        setGrafo(grafo.concat(listaDeAristas));\r\n    };\r\n\r\n    const previewValidation = () => {\r\n\r\n        if (rows[0].length === 0 || links[0].from.length === 0) {\r\n            swal('Campos vacíos', 'Para continuar con la aplicación, debes completar los campos vacíos', 'error')\r\n        }\r\n        else {\r\n            setValidation(true);\r\n        }\r\n    }\r\n\r\n\r\n    const saveData = () => {\r\n\r\n        previewValidation();\r\n\r\n        if (validation === true) {\r\n\r\n            setSaveAllData(true);\r\n            // Implementanción del grafo\r\n            bugout.info('Creando nodo');\r\n            const gra = Grafo.desdeListaDeAristas(grafo, false);\r\n            const { esEuleriano, esHamiltoniano, esConexo, matrizDeCaminos, arbolGeneradorMinimo: agm } = gra;\r\n            const { camino: shortPathGraph, distancia: distanceShortes } = gra.caminoMasCorto(distanceFrom, distanceTo);\r\n            const peak = gra.flujoMaximo(peakFlowFrom, peakFlowTo);\r\n\r\n            setArbolGenerador(agm.arbol.map((arista) => arista.link));\r\n            setMatrizDeCamino(matrizDeCaminos);\r\n            setIsHamiltoniano(esHamiltoniano);\r\n            setIsEuleriano(esEuleriano);\r\n            setIsConexo(esConexo);\r\n            setDistance(distanceShortes);\r\n            setShortPath(shortPathGraph);\r\n            setPeakFlow(peak);\r\n            setEulerianPath(gra.euleriano(Trayecto.camino));\r\n            setEulerianCycle(gra.euleriano(Trayecto.ciclo));\r\n            setHamiltonianPath(gra.hamiltoniano(Trayecto.camino));\r\n            setHamiltonianCycle(gra.hamiltoniano(Trayecto.ciclo));\r\n            bugout.info('Guardado de información para la generación del grafo');\r\n\r\n        } else bugout.error('Ha ocurrido un error en la validación de los datos');\r\n\r\n    };\r\n\r\n    function refreshPage(e) {\r\n        e.preventDefault()\r\n        window.location.reload();\r\n        bugout.info('Recarga de página');\r\n    }\r\n\r\n    const handleArbol = () => {\r\n        !doneFetchArbol ? (setDoneFetchArbol(true)) : setDoneFetchArbol(false);\r\n    };\r\n\r\n    const handleFlujoMaximo = () => {\r\n        !doneFetchFlujoMaximo ? (setDoneFetchFlujoMaximo(true)) : setDoneFetchFlujoMaximo(false);\r\n    };\r\n\r\n    const handleDistance = () => {\r\n        !doneFetchDistance ? (setDoneFetchDistance(true)) : setDoneFetchDistance(false);\r\n\r\n    };\r\n\r\n    const handleHamEul = () => {\r\n        !doneFetchHamEul ? (setDoneFetchHamEul(true)) : setDoneFetchHamEul(false);\r\n    };\r\n\r\n    const handleMatriz = () => {\r\n        !doneFetch ? (setDoneFetch(true)) : setDoneFetch(false);\r\n    };\r\n\r\n    const handleOnChange = (index, text, value) => {\r\n        const copyRows = [...rows];\r\n        const key = index;\r\n        copyRows[index] = {\r\n            ...copyRows[index],\r\n            key,\r\n            [text]: value\r\n        };\r\n        setRows(copyRows);\r\n        bugout.info('Has cambiado algún valor de los nodos');\r\n\r\n    };\r\n\r\n\r\n    const handleOnAdd = () => {\r\n        let len = rows.length - 1;\r\n        rows[len].text.length > 0 ? (setRows(rows.concat(defaultState))) : swal('Error en los nodos', 'Campos vacíos, por favor asigne nombre a los nodos creados', 'error');\r\n    };\r\n\r\n    const handleOnAddLink = () => {\r\n        let len = links.length - 1;\r\n        (links[len].from.length > 0 || links[len].to.length > 0 || links[len].text.length > 0) ? (\r\n            setLinks(links.concat(defaultState))\r\n        ) : swal('Error en los links', 'Campos vacíos en los links, por favor complete los datos antes de continuar', 'error');\r\n    };\r\n\r\n    const handleOnRemove = index => {\r\n        if (rows.length === 1) {\r\n            swal('Error en los nodos', 'No se puede eliminar el único campo de nodos', 'error')\r\n        } else {\r\n            const copyRows = [...rows];\r\n            copyRows.splice(index, 1);\r\n            setRows(copyRows);\r\n            saveData();\r\n        }\r\n\r\n        saveData();\r\n        bugout.warn('Has borrado un campo de los nodos');\r\n\r\n    };\r\n\r\n    const handleOnChangeLinks = (index, from, value, text, to) => {\r\n        // links cambios agregar\r\n        const copyLinks = [...links];\r\n        copyLinks[index] = {\r\n            ...copyLinks[index],\r\n            [from]: value,\r\n            [to]: value,\r\n            [text]: value,\r\n        };\r\n        setLinks(copyLinks);\r\n        //Guardar en clase\r\n        if (copyLinks[index].from && copyLinks[index].to && copyLinks[index].text)\r\n            saveArista(copyLinks[index].from, copyLinks[index].to, copyLinks[index].text)\r\n        bugout.info('Has cambiado algún valor de los links');\r\n\r\n    };\r\n\r\n    const handleOnRemoveLink = index => {\r\n        if (links.length === 1) {\r\n            swal(\"Error en los links\", 'No se puede eliminar el único elemento de los links', 'error')\r\n            bugout.error('No se puede eliminar el único elemento de los links');\r\n        } else {\r\n            const copyLinks = [...links];\r\n            copyLinks.splice(index, 1);\r\n            setLinks(copyLinks);\r\n        }\r\n        saveData();\r\n        bugout.info('Link eliminado correctamente');\r\n\r\n    };\r\n\r\n\r\n    // Obtener valores desde y hasta para implementar Dijkstra\r\n\r\n    const handleSubmitFromTo = (e) => {\r\n        e.preventDefault();\r\n        getFromTo(changeData)\r\n    };\r\n\r\n    const handleInputChangeFromTo = (e) => {\r\n        e.preventDefault();\r\n        setChangeData({\r\n            ...changeData,\r\n            [e.target.name]: e.target.value,\r\n        });\r\n        bugout.info('Datos de distancia entre dos nodos actualizada');\r\n    }\r\n\r\n    const getFromTo = ({ desde, hasta }) => {\r\n        if (desde && hasta) {\r\n            setDistanceFrom(Number(desde));\r\n            setDistanceTo(Number(hasta));\r\n        }\r\n    }\r\n\r\n    // Enviar changeData para actualizar formulario\r\n    const peakFlowFromTo = ({ from, to }) => {\r\n        if (from && to) {\r\n            setPeakFlowFrom(Number(from));\r\n            setPeakFlowTo(Number(to));\r\n        }\r\n        bugout.info('Datos de flujo máximo actualizados');\r\n    }\r\n\r\n\r\n    const handleInputPeakFlow = (e) => {\r\n        e.preventDefault();\r\n        setChangePeakData({\r\n            ...changePeakData,\r\n            [e.target.name]: e.target.value,\r\n        })\r\n\r\n    }\r\n\r\n    const handleSubmitPeak = (e) => {\r\n        e.preventDefault();\r\n        peakFlowFromTo(changePeakData);\r\n    };\r\n\r\n\r\n\r\n\r\n    return (\r\n        <Box display='flex' className='main_view'>\r\n            <div className='main_options'>\r\n                <Button m={10} variant='contained' color='secondary' onClick={handleOnAdd}>Agregar</Button>\r\n                {rows.map((row, index) => {\r\n                    bugout.info('Se ha creado un nuevo nodo');\r\n                    return (\r\n                        <Row\r\n                            {...row}\r\n                            className='main_row'\r\n                            onChange={(text, value) => handleOnChange(index, text, value)}\r\n                            onRemove={() => handleOnRemove(index)}\r\n                            key={index}\r\n                        />\r\n                    )\r\n                })}\r\n\r\n                <hr />\r\n                <Button m={10} variant='contained' color='grey' onClick={handleOnAddLink}>Agregar link</Button>\r\n                {links.map((link, index) => {\r\n                    bugout.info('Se ha creado un nuevo link');\r\n                    return (\r\n                        <RowLink\r\n                            {...link}\r\n                            className='main_row'\r\n                            onChange={(from, to, value, text) => handleOnChangeLinks(index, from, to, value, text)}\r\n                            onRemove={() => handleOnRemoveLink(index)}\r\n                            key={index}\r\n                        />\r\n                    )\r\n                })}\r\n\r\n                <div>\r\n\r\n                    {\r\n                        (links.length < 1 || rows.length < 1) ? (\r\n                            <Button m={10}\r\n                                className='main_row'\r\n                                variant='contained'\r\n                                color='primary'\r\n                                disabled\r\n                            >\r\n                                GUARDAR DATOS\r\n                                <SaveAlt />\r\n                            </Button>\r\n                        ) : (\r\n                            <Button m={10}\r\n                                className='main_row'\r\n                                variant='contained'\r\n                                color='primary'\r\n                                onClick={saveData}\r\n                            >\r\n                                GUARDAR DATOS\r\n                                <SaveAlt />\r\n                            </Button>\r\n                        )\r\n                    }\r\n                </div>\r\n\r\n                {/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleMatriz}\r\n                            disabled\r\n                        >\r\n                            MATRIZ DE CAMINO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleMatriz}\r\n                        >\r\n                            MATRIZ DE CAMINO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetch === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <div className=\"item\">\r\n\r\n                        {\r\n                            matrizDeCamino &&\r\n                            matrizDeCamino.map((item, index) => (\r\n                                <div className=\"main_boxItem\">\r\n                                    <p>{index}</p>\r\n                                    {bugout.info('Acceso a sección Matriz de camino')}\r\n                                    {\r\n\r\n                                        item.map(miniItem => (\r\n                                            <div className=\"main_boxMiniItem\">\r\n                                                <p className='main_p'>{miniItem} &nbsp; </p>\r\n                                            </div>\r\n                                        ))\r\n\r\n                                    }\r\n                                </div>\r\n                            ))\r\n                        }\r\n                        <p className='main_isConexo'>\r\n                            {\r\n                                (isConexo === true) ? ('El grafo es conexo') : ('El grafo no es conexo')\r\n                            }\r\n                        </p>\r\n                    </div>\r\n                </div >\r\n                {/* ------------------------ MATRIZ DE CAMINO ------------------------ */}\r\n\r\n\r\n                {/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleDistance}\r\n                            disabled\r\n                        >\r\n                            DISTANCIA ENTRE DOS NODOS\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleDistance}\r\n\r\n                        >\r\n                            DISTANCIA ENTRE DOS NODOS\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div\r\n                    className={\r\n                        doneFetchDistance === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                    }>\r\n                    <form className='main_formDistance' onSubmit={handleSubmitFromTo}>\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number'\r\n                            label='Desde'\r\n                            type='number'\r\n                            name='desde'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputChangeFromTo}\r\n                            InputLabelProps={{\r\n                                shrink: true,\r\n                            }}\r\n                        />\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number'\r\n                            label='Hasta'\r\n                            type='number'\r\n                            name='hasta'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputChangeFromTo}\r\n                            InputLabelProps={{ shrink: true, }}\r\n                        />\r\n\r\n                        <Button\r\n                            variant='contained'\r\n                            color='primary'\r\n                            type='submit'\r\n                            onClick={saveData}\r\n                        ><RefreshIcon />\r\n                        </Button>\r\n                    </form>\r\n                    {\r\n                        changeData.desde && changeData.hasta ? (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Los nodos recorridos son los siguientes: </p>\r\n                                {bugout.info('Acceso sección de Distancia entre dos nodos')}\r\n                                {shortPath.map(item => (\r\n                                    <p className='main_distanceItem'>{item}</p>\r\n                                ))}\r\n                                <p>\r\n                                    Distancia : {distance}\r\n                                </p>\r\n                            </div>\r\n                        ) : bugout.error('Ocurrió un error al momento de desplegar la información de distancia entre dos nodos')\r\n                    }\r\n\r\n                </div >\r\n                {/* ------------------------ DISTANCIA ENTRE DOS NODOS ------------------------ */}\r\n\r\n                {/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\r\n\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleHamEul}\r\n                            disabled\r\n                        >\r\n                            HAMILTONIANO Y/O EULERIANO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleHamEul}\r\n                        >\r\n                            HAMILTONIANO Y/O EULERIANO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchHamEul === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <div className='distanceFromTo'>\r\n                        {bugout.info('Acceso sección de Hamiltoniano/Euleriano')}\r\n                        <p>\r\n                            {\r\n                                !isHamiltoniano ? ('El grafo no es hamiltoniano') : ('El grafo es hamiltoninao')\r\n                            }\r\n\r\n                            {\r\n                                hamiltonianCycle ? (\r\n                                    <>\r\n                                        <p>Tiene como ciclo: </p>\r\n                                        {\r\n                                            hamiltonianCycle.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay ciclo euleriano')\r\n                            }\r\n\r\n                            {\r\n                                hamiltonianPath ? (\r\n                                    <>\r\n                                        <p>Tiene como camino: </p>\r\n                                        {\r\n                                            hamiltonianPath.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay camino hamiltoniano')\r\n                            }\r\n\r\n                        </p>\r\n                        <p>\r\n                            {\r\n                                !isEuleriano ? ('El grafo no es euleriano') : ('El grano es euleriano')\r\n                            }\r\n\r\n                            {\r\n                                eulerianCycle ? (\r\n                                    <>\r\n                                        <p>Tiene como ciclo: </p>\r\n                                        {\r\n                                            eulerianCycle.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay ciclo euleriano')\r\n                            }\r\n\r\n                            {\r\n                                eulerianPath ? (\r\n                                    <>\r\n                                        <p>Tiene como camino: </p>\r\n                                        {\r\n                                            eulerianPath.map(item => (\r\n                                                <p className='main_pathOrCycle'> {item} </p>\r\n                                            ))\r\n                                        }\r\n                                    </>\r\n\r\n                                ) : bugout.warn('No hay camino euleriano')\r\n                            }\r\n                        </p>\r\n                    </div>\r\n                </div >\r\n                {/* ------------------------ HAMILTONIANO/EULERIANO ------------------------ */}\r\n\r\n\r\n                {/* ------------------------ FLUJO MÁXIMO ------------------------ */}\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleFlujoMaximo}\r\n                            disabled\r\n                        >\r\n                            FLUJO MÁXIMO\r\n                        </Button>\r\n                    ) : (\r\n                        <Button m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleFlujoMaximo}\r\n                        >\r\n                            FLUJO MÁXIMO\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchFlujoMaximo === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <form className='main_formDistance' onSubmit={handleSubmitPeak}>\r\n                        {bugout.info('Acceso sección de Flujo máximo')}\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number-peak'\r\n                            label='Desde'\r\n                            type='number'\r\n                            name='from'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputPeakFlow}\r\n                            InputLabelProps={{\r\n                                shrink: true,\r\n                            }}\r\n                        />\r\n                        <TextField\r\n                            className='main_textFieldDistance'\r\n                            id='filled-number-peak'\r\n                            label='Hasta'\r\n                            type='number'\r\n                            name='to'\r\n                            InputProps={{ inputProps: { min: 0, max: 99 } }}\r\n                            onChange={handleInputPeakFlow}\r\n                            InputLabelProps={{ shrink: true, }}\r\n                        />\r\n                        <Button\r\n                            variant='contained'\r\n                            color='gray'\r\n                            type='submit'\r\n                            onClick={saveData}\r\n                        ><RefreshIcon />\r\n                        </Button>\r\n                    </form>\r\n                    {\r\n                        changePeakData.from && changePeakData.to ? (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Flujo máximo es: {peakFlow}</p>\r\n                                {bugout.info('Acceso sección de Flujo máximo')}\r\n                            </div>\r\n                        ) : (\r\n                            <div className='distanceFromTo'>\r\n                                <p>Flujo máximo resultante es: {peakFlow}</p>\r\n                            </div>\r\n                        )\r\n                    }\r\n                </div >\r\n\r\n                {/* ------------------------ FLUJO MÁXIMO ------------------------ */}\r\n\r\n                {/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\r\n                {\r\n                    !saveAllData ? (\r\n                        <Button\r\n                            m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleArbol}\r\n                            disabled\r\n                        >\r\n                            ÁRBOL GENERADOR\r\n                        </Button>\r\n                    ) : (\r\n                        <Button\r\n                            m={10}\r\n                            className='main_row'\r\n                            variant='contained'\r\n                            color='primary'\r\n                            onClick={handleArbol}\r\n                        >\r\n                            ÁRBOL GENERADOR\r\n                        </Button>\r\n                    )\r\n                }\r\n\r\n                <div className={\r\n                    doneFetchArbol === true ? ('main_isMatriz') : 'main_noMatriz'\r\n                }>\r\n                    <div className='main_contentInside'>\r\n                        {\r\n                            arbolGenerador &&\r\n                            <NotDirected className=\"hola\" data={rows} linksData={arbolGenerador} />\r\n                        }\r\n                        {bugout.info('Acceso sección de Árbol generador')}\r\n                    </div>\r\n                </div >\r\n\r\n                {/* ------------------------ ÁRBOL GENERADOR ------------------------ */}\r\n\r\n                <Button type=\"button\" onClick={refreshPage}> Recargar la página <span><CachedIcon className='main_reloadIcon' /></span> </Button>\r\n                <Button type='button' onClick={downloadLogs}>Obtener registro de actividad</Button>\r\n\r\n            </div >\r\n\r\n            <NotDirected data={rows} linksData={links} />\r\n        </Box >\r\n    )\r\n}\r\n\r\n\r\nexport default MainNotDirected;\r\n","import React from 'react'\r\nimport { Link } from 'react-router-dom'\r\n\r\nconst InitialPage = () => {\r\n    return (\r\n        <div className='initialPage_container'>\r\n            <div className='initalPage_item'>\r\n                <Link to='/dirigido'>\r\n                    DIRIGIDO\r\n            </Link>\r\n            </div>\r\n            <div className='initalPage_item'>\r\n                <Link to='/no-dirigido'>\r\n                    NO DIRIGIDO\r\n            </Link>\r\n            </div>\r\n\r\n            <div className='initalPage_item'>\r\n                <Link to='/documentacion'>\r\n                    DOCUMENTACIÓN\r\n                </Link>\r\n            </div>\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default InitialPage;\r\n","export default __webpack_public_path__ + \"static/media/doc-ex.89254a2c.PNG\";","export default __webpack_public_path__ + \"static/media/link-ex.35ce9f1d.PNG\";","export default __webpack_public_path__ + \"static/media/graph.e7666be6.PNG\";","import React from 'react';\r\nimport DocEx from '../assets/img/doc-ex.PNG';\r\nimport LinkEx from '../assets/img/link-ex.PNG';\r\nimport Graph from '../assets/img/graph.PNG';\r\nimport { Link } from 'react-router-dom';\r\n\r\nconst Documentation = () => {\r\n    return (\r\n        <div className='documentation_container'>\r\n            <h2>Documentación de aplicación de grafos</h2>\r\n            <p>A continuación encontrarás la documentación de nuestra aplicación de grafos además de una serie de recomendaciones para que\r\n            tu experiencia dentro de la aplicación sea la más grata posible.\r\n            </p>\r\n            <h3>Recomendación inicial</h3>\r\n            <ul>\r\n                <p>Por motivos de la librería que utilizamos para el desarrollo y trabajo de nodos, estos\r\n                deben trabajarse como si fuesen referenciados desde índice 0, independiente del nombre que\r\n                posean. A continuación de mostrará un ejemplo de implementación:\r\n                </p>\r\n            </ul>\r\n            <div className='documentation_ex'>\r\n                <img src={DocEx} alt='Ejemplificación de nombre' />\r\n                <p className='documentation_info'>Dada la imagen anterior, sumado a la información anterior, debemos concluir\r\n                que <span className='spanBlack'> el nodo llamado &quot;Primer nodo&quot; tendrá como referencia el número &quot;0&quot;.</span> Por consiguiente, el nodo\r\n                llamado &quot;Segundo nodo&quot; tendrá asignado el número &quot;1&quot;. Finalmente, los nodos &quot;Tercer\r\n                nodo&quot; y &quot;Cuarto nodo&quot; tendrán asignados los valores &quot;2&quot; y &quot;3&quot;, respectivamente.\r\n                </p>\r\n            </div>\r\n            <ul>\r\n                Por lo tanto, si queremos unir los nodos anteriormente planteados, debemos hacerlo de la siguiente manera:\r\n            </ul>\r\n            <div className='documentation_ex'>\r\n                <img src={LinkEx} alt='Ejemplificación de links' />\r\n                <p className='documentation_info'>y obtenemos ... </p>\r\n                <img src={Graph} alt='Grafo final' />\r\n            </div>\r\n            <ul>\r\n                Finalmente, para que tu experiencia dentro de la aplicación sea la mejor, <span className='spanBlack'>te recomendamos trabajar los nodos con nombres\r\n                que inicien desde el 0 hacia delante</span>. Sin embargo, puedes colocar cualquier nombre que desees y puedes editarlo en cualquier momento\r\n                pero debes tener siempre en cuenta el ejemplo anterior.\r\n            </ul>\r\n            <h3>Limitaciones</h3>\r\n            <ul>\r\n                <li>\r\n                    Nuestra aplicación está pensada para ser trabajada desde computadores o pantallas de grandes dimensiones,\r\n                    motivo por el cual <span className='spanBlack'>nuestro programa no es responsive</span>, es decir, no es adaptable a dispositivos más pequeños\r\n                    al anteriormente mencionado.\r\n                </li>\r\n            </ul>\r\n            <h3>Comandos</h3>\r\n            <ul>\r\n                <li>\r\n                    Si deseas agrandar o disminuir el tamaño de los nodos, solo debes usar la tecla <span className='spanBlack'>CTRL</span> y usar la rueda del mouse o el botón \r\n                    <span className='spanBlack'> +</span> o <span className='spanBlack'>-</span>.\r\n                </li>\r\n                <li>\r\n                    Si tienes problemas de visualización de la aplicación, como tamaños desproporcionados, te recomendamos hacer redimensionar la ventana.\r\n                </li>\r\n            </ul>\r\n            <h3>Páginas</h3>\r\n            <p>Nuestra aplicación cuenta con 3 secciones además de esta:</p>\r\n            <ul>\r\n                <li>\r\n                    <Link to='/'>\r\n                        Página inicial\r\n                    </Link >\r\n                    <p>Página inicial de la aplicación, aquí podrás escoger entre trabajar con grafos dirigidos o no dirigidos.</p>\r\n                </li>\r\n                <li>\r\n                    <Link to='/dirigido'>\r\n                        Página para grafos dirigidos\r\n                    </Link >\r\n                    <p>Página para trabajar con grafos dirigidos.</p>\r\n\r\n                </li>\r\n                <li>\r\n                    <Link to='/no-dirigido'>\r\n                        Página para grafos no dirigidos\r\n                </Link >\r\n                <p>Página para trabajar con grafos no dirigidos.</p>\r\n\r\n                </li>\r\n            </ul>\r\n            <h3>Errores y alertas</h3>\r\n            <ul>\r\n                <li>\r\n                    En caso de realizar alguna acción que no se encuentre permitida, nuestra aplicación está diseñada para <span className='spanBlack'>indicarte el error\r\n                    además de la ubicación del mismo junto a su respectiva solución.</span>\r\n                </li>\r\n\r\n            </ul>\r\n            <h3>Registro de actividad</h3>\r\n            <ul>\r\n                <li>\r\n                    Dentro de las secciones de grafos dirigidos y no dirigidos, encontrarás un botón llamado <span className='spanBlack'>OBTENER REGISTRO DE ACTIVDAD</span>, \r\n                    con el cual podrás descargar un archivo .txt el que tendrá todas las acciones que has realizado en la aplicación, tanto la <span className='spanBlack'>información, alertas y errores.</span>\r\n                </li>\r\n\r\n            </ul>\r\n            <h3>Secciones</h3>\r\n            <ul>\r\n                <li className='spanBlue'>Matríz de camino</li>\r\n                <p>Podrás visualizar una matriz de caminos y verificar si el grafo ingresado es o no conexo.</p>\r\n                <li className='spanBlue'>Distancia entre dos nodos</li>\r\n                <p>Mostrará el recorrido que hay entre dos nodos además de la distancia entre los mismos.</p>\r\n                <li className='spanBlue'>Euleriano y/o hamiltoniano</li>\r\n                <p>Determinará si un grafo es Euleriano y/o Hamiltoniano. Por otra parte, mostrará el camino o ciclo en caso de que exista.</p>\r\n                <li className='spanBlue'>Flujo máximo</li>\r\n                <p>Determina el flujo máximo que hay entre dos nodos.</p>\r\n                <li className='spanBlue'>Árbol generador</li>\r\n                <p>Podrás ver el árbol que se genera a causa del grafo. Tienes la libertad de mover los nodos como gustes dentro de el contenedor.</p>\r\n            </ul>\r\n\r\n            <h3>Tecnologías usadas</h3>\r\n            <ul>\r\n                <li>\r\n                    <a href='https://es.reactjs.org/'>\r\n                        React JS\r\n                    </a>\r\n                </li>\r\n                <li>\r\n                    <a href='https://www.javascript.com/'>\r\n                        JavaScript\r\n                    </a>\r\n                </li>\r\n                <li>\r\n                    <a href='https://gojs.net/latest/index.html'>\r\n                        GoJS\r\n                    </a>\r\n                </li>\r\n                <li>\r\n                    <a href='https://lodash.com/'>\r\n                        Lodash\r\n                    </a>\r\n                </li>\r\n                <li>\r\n                    <a href='https://jestjs.io/'>\r\n                        Jest\r\n                    </a>\r\n                </li>\r\n                <li>\r\n                    <a href='https://github.com/inorganik/debugout.js'>\r\n                        Debugout.js\r\n                    </a>\r\n                </li>\r\n            </ul>\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Documentation;","import React from 'react';\r\nimport { BrowserRouter, Redirect, Route, Switch} from 'react-router-dom'\r\nimport Main from './components/Main';\r\nimport Header from './components/Header';\r\nimport MainNotDirected from './components/MainNotDirected';\r\nimport InitialPage from './components/InitialPage';\r\nimport Documentation from './components/Documentation';\r\n\r\nconst App = () => (\r\n  <BrowserRouter>\r\n    <Header />\r\n    <Switch>\r\n      <Route exact path='/' component={InitialPage} />\r\n      <Route exact path='/dirigido' component={Main} />\r\n      <Route exact path='/no-dirigido' component={MainNotDirected} />\r\n      <Route exact path='/documentacion' component={Documentation} />\r\n      <Redirect to='/' />\r\n    </Switch>\r\n    \r\n\r\n  </BrowserRouter>\r\n\r\n)\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './assets/styles/settings.scss'\r\nimport App from './App';\r\nimport \"core-js/stable\";\r\nimport \"regenerator-runtime/runtime\";\r\n\r\nReactDOM.render(\r\n  <>\r\n    <App />\r\n  </>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}